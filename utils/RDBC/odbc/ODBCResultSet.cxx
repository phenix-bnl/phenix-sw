// $Id: ODBCResultSet.cxx,v 1.3 2007/02/28 21:33:40 phnxbld Exp $
//*-- Author : Valeriy Onuchin 14/02/2000 
//

/**************************************************************************

   ROOT wrappers of libodbc++ library
    
   Copyright (C) 1999-2000 Manush Dodunekov <manush@stendahls.net>
   
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.
   
   You should have received a copy of the GNU Library General Public License
   along with this library; see the file COPYING.  If not, write to
   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.

**************************************************************************/

//
/////////////////////////////////////////////////////////////////////
//
// A TSQLResultSet provides access to a table of data. A 
// TSQLResultSet object is usually generated by executing 
// TSQLStatement. 
//
// A TSQLResultSet maintains a cursor pointing to its current row 
// of data. Initially the cursor is positioned before the first
// row. The Next() method moves the cursor to the next row. 
//
// The GetXXX methods retrieve column values for the current row.
// You can retrieve values using either the index number of the 
// column or the name of the column. In general,using the column 
// index will be more efficient. Columns are numbered from 1. 
//
// For maximum portability, TSQLResultSet columns within each row
// should be read in left-to-right order and each column should be 
// read only once. 
//
// For the GetXXX methods, the driver attempts to convert the
// underlying data to the specified ROOT type and returns a suitable 
// value. See the specification for allowable mappings 
// from SQL types to ROOT types with the ODBCResultSet::GetXXX 
// methods. 
//
// Column names used as input to GetXXX methods are case
// insensitive. When performing a GetXXX using a column name, 
// if several columns have the same name, then the value of the 
// first matching column will be returned. The column name option 
// is designed to be used when column names are used in the SQL 
// query. For columns that are NOT explicitly named in the query, 
// it is best to use column numbers. If column names are used, there 
// is no way for the programmer to guarantee that they actually refer 
// to the intended columns. 
//
// A TSQLResultSet is automatically closed by the TSQLStatement that 
// generated it when that TSQLStatement is closed, re-executed, 
// or used  to retrieve the next result from a sequence of multiple 
// results. 
//
// The number, types and properties of a TSQLResultSet's columns are
// provided by the TSQLResulSetMetaData object returned by the 
// GetMetaData() method. 
//
// See also: 
//      TSQLStatement::ExecuteQuery(const TString&),
//      TSQLStatement::GetResultSet(), TSQLResultSetMetaData
//
//___________________________________________________________________
//
//       kCONCUR_READ_ONLY 
//
// The concurrency mode for a TSQLResultSet object that may 
// NOT be updated.
//___________________________________________________________________
//
//       kCONCUR_UPDATABLE 
//
//  The concurrency mode for a TSQLResultSet
//  object that may be updated.
//___________________________________________________________________
//
//       kFETCH_FORWARD 
//
// The rows in a result set will be
// processed in a forward direction; first-to-last.
//___________________________________________________________________
//
//       kFETCH_REVERSE 
//
// The rows in a result set will be
// processed in a reverse direction; last-to-first.
//___________________________________________________________________
//
//       kFETCH_UNKNOWN 
//
// The order in which rows in a result set
// will be processed is unknown.
//___________________________________________________________________
//
//       kTYPE_FORWARD_ONLY 
//
// The type for a TSQLResultSet object whose
// cursor may move only forward.
//___________________________________________________________________
//
//       kTYPE_SCROLL_INSENSITIVE 
//
// The type for a TSQLResultSet object that is
// scrollable but generally not sensitive to changes made by
// others.
//___________________________________________________________________
//
//       kTYPE_SCROLL_SENSITIVE 
// 
// The type for a TSQLResultSet object that is
// scrollable and generally sensitive to changes made by
// others.
//
/////////////////////////////////////////////////////////////////////
 
#include <ODBCResultSet.h>
#include <ODBCResultSetMetaData.h>
#include <ODBCStatement.h>
#include <TList.h>
#include <TMath.h>
#include <TStopwatch.h>
#include <TBuffer.h>
#include <TTree.h>
#include <TRandom.h>
#include <TBranch.h>
#include <RDBC/odbc++/resultset.h>
#include <RDBC/odbc++/resultsetmetadata.h>
#include <iostream>
#include <sstream>
#include <ctype.h>
#include <time.h>
#include <TSQLRow.h>

#if ROOT_VERSION_CODE >= ROOT_VERSION(5,15,0)
#include <TBufferFile.h>
#endif

using namespace odbc;
using namespace std;

ClassImpQ(ODBCResultSet)

/////////////////////////////////////////////////////////////////////
class RDBCRow: public TSQLRow
{
friend  class ODBCResultSet;

private:
   TSQLResultSet* fResultSet; // parent result set
   RDBCRow(TSQLResultSet *result=0) { fResultSet=result; }
   RDBCRow* Set(TSQLResultSet *result) { fResultSet=result; return this; }
   virtual ~RDBCRow() {  fResultSet = 0; }
   TString fField;  // selected field

public:
   void        Close(Option_t* /* opt="" */) { fResultSet = 0; }
   ULong_t     GetFieldLength(Int_t field) { return fResultSet ? fResultSet->GetMetaData()->GetColumnDisplaySize(field-1) : 0; }
   const char* GetField(Int_t field) { fField = fResultSet ? fResultSet->GetString(field-1).Data() : ""; return fField.Data(); }
}; 

/////////////////////////////////////////////////////////////////////
//___________________________________________________________________
ODBCResultSet::ODBCResultSet(TSQLStatement* stmt,void* imp):
   TSQLResultSet(stmt,imp)
{
   // ctor
   
   fStatement = stmt;
   odbc::ResultSet* rs = (odbc::ResultSet*)imp;
   fImp = rs;
   fRow = new RDBCRow(this);
   
   try {
      odbc::ResultSetMetaData* mdimp = rs->getMetaData();
      fMetaData = new ODBCResultSetMetaData(this,mdimp);    

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}                             

//___________________________________________________________________
ODBCResultSet::~ODBCResultSet()
{
   // destructor. 

   odbc::ResultSet* imp = (odbc::ResultSet*)fImp;  

   try {
      if(imp) delete imp; 
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }

   fImp = 0; 
   
   if(fMetaData) delete ((ODBCResultSetMetaData*)fMetaData);
   if(fRow) delete fRow;
   
   ODBCStatement* stmt = (ODBCStatement*)fStatement;
   if(stmt->fCurrentResult==this) stmt->fCurrentResult = 0;

   fMetaData = 0;
   fRow = 0;
}

//___________________________________________________________________
Bool_t ODBCResultSet::WasNull()
{
   // Reports whether the last column read had a value of SQL NULL. 
   // Note that you must first call GetXXX on a column to try to 
   // read its value and then call WasNull() to see if the value 
   // read was SQL NULL.
   //
   // Returns:
   //       kTRUE if last column read was SQL NULL and 
   //       kFALSE - otherwise
   //  Throws:
   //       TSQLException - if a database access error occurs
 
   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      return_value = rs->wasNull();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
TString ODBCResultSet::GetString( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a TString.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, the result 
   //       is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   TString str;
   
   if(!fImp) { Destroyed(); return str; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {
      str = ODBCXX_STRING_CSTR( rs->getString(columnIndex) );  

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return ""; 
   }
   return str;
}

//___________________________________________________________________
Bool_t ODBCResultSet::GetBoolean( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a boolean.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, the result is
   //       kFALSE
   //  Throws:
   //       TSQLException - if a database access error occurs

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {    
      return_value =  rs->getBoolean(columnIndex);
   
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
Char_t ODBCResultSet::GetByte( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a byte.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   Char_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value =  rs->getByte(columnIndex);
      
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;   
}

//___________________________________________________________________
Short_t ODBCResultSet::GetShort( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Short_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   Short_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->getShort(columnIndex);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Int_t ODBCResultSet::GetInt( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Int_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   Int_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->getInt(columnIndex);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Long_t ODBCResultSet::GetLong( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Long_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   Long_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->getLong(columnIndex);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Float_t ODBCResultSet::GetFloat( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Float_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   Float_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {      
      return_value = rs->getFloat(columnIndex);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Double_t ODBCResultSet::GetDouble( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Double_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   Double_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {      
      return_value = rs->getDouble(columnIndex);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
TArrayC ODBCResultSet::GetBytes( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a char array.
   // The chars represent the raw values returned by the driver.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs
 
   TArrayC array;
   
   if(!fImp) { Destroyed(); return array; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {           
      ODBCXX_BYTES b = rs->getBytes(columnIndex);
      
      array.Set( (Int_t)ODBCXX_BYTES_SIZE(b),
                 (Char_t*)ODBCXX_BYTES_DATA(b) );

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
   return array;
}

//___________________________________________________________________
TSQLDate ODBCResultSet::GetDate( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a TSQLDate
   // object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   TSQLDate return_value;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      odbc::Date dt = rs->getDate(columnIndex);
      return_value = TSQLDate( dt.getYear(),
                               dt.getMonth(),
                               dt.getDay() );

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
   return return_value;
}

//___________________________________________________________________
TSQLTime ODBCResultSet::GetTime( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a TSQLTime
   // object.
   //
   // Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   TSQLTime return_value;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      odbc::Time tm = rs->getTime(columnIndex);

      return_value = TSQLTime( tm.getHour(),
                               tm.getMinute(),
                               tm.getSecond() );

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
   return return_value;
}

//___________________________________________________________________
TSQLTimestamp ODBCResultSet::GetTimestamp( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a
   // TSQLTimestamp object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   TSQLTimestamp return_value;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      odbc::Timestamp tmstmp = rs->getTimestamp(columnIndex);
      return_value = TSQLTimestamp( tmstmp.getYear(),
                                    tmstmp.getMonth(),
                                    tmstmp.getDay(), 
                                    tmstmp.getHour(),
                                    tmstmp.getMinute(),
                                    tmstmp.getSecond(),
                                    tmstmp.getNanos() );

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
   return return_value;
}

//___________________________________________________________________
TBuffer* ODBCResultSet::GetAsciiStream( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a stream 
   // of ASCII characters. The value can then be read in chunks from 
   // the stream. This method is particularly suitable for 
   // retrieving large LONGVARCHAR values. The driver will do 
   // any necessary conversion from the database format into ASCII. 
   //
   //  Note: All the data in the returned stream must be read prior 
   //    to getting the value of any other column. The next call to 
   //    a get method implicitly closes the stream. Also, a stream 
   //    may return 0 when the method available is called whether 
   //    there is data available or not.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       A TBuffer that delivers the database column 
   //       value as a stream of one char ASCII characters. 
   //       If the value is SQL NULL then the result is null.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs

   TBuffer* buffer = 0;

   if(!fImp) { Destroyed(); return buffer; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {   
      ODBCXX_STREAM* rsStream = rs->getAsciiStream(columnIndex);
      Int_t bufsiz = rsStream->rdbuf()->in_avail();
      if(bufsiz<=0) return 0;
#if ROOT_VERSION_CODE >= ROOT_VERSION(5,15,0)
      buffer  = new TBufferFile(TBuffer::kWrite, bufsiz); 
#else
      buffer  = new TBuffer(TBuffer::kWrite, bufsiz); 
#endif
      int c;
      while ((c = rsStream->get()) != EOF)
	{
	  *buffer << (char) c;
	}
      buffer->SetBufferOffset();
      buffer->SetReadMode();
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      buffer = 0;
   }
   return buffer;
}

//___________________________________________________________________
TBuffer* ODBCResultSet::GetBinaryStream( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a stream of
   // uninterpreted chars. The value can then be read in chunks 
   // from the stream. This method is particularly suitable for
   //  retrieving large LONGVARBINARY values. 
   //
   //  Note: All the data in the returned stream must be read 
   //    prior to getting the value of any other column. The next 
   //    call to a Get method implicitly closes the stream. Also, 
   //    a stream may return 0 when the method available is called 
   //    whether there is data available or not.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       TBuffer that delivers the database column 
   //       value as a stream of uninterpreted chars. If the value 
   //       is SQL NULL then the result is null.
   //  Throws:
   //       TSQLException - if a database access error occurs

   TBuffer* buffer = 0;

   if(!fImp) { Destroyed(); return buffer; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {   
      ODBCXX_STREAM* rsStream = rs->getBinaryStream(columnIndex);
      Int_t bufsiz = rsStream->rdbuf()->in_avail();
      if(bufsiz<=0) return 0;
#if ROOT_VERSION_CODE >= ROOT_VERSION(5,15,0)
      buffer  = new TBufferFile(TBuffer::kWrite, bufsiz); 
#else
      buffer  = new TBuffer(TBuffer::kWrite, bufsiz); 
#endif
      int c;
      while ((c = rsStream->get()) != EOF)
	{
	  *buffer << (char) c;
	}
      buffer->SetBufferOffset();
      buffer->SetReadMode();
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      buffer = 0;
   }
   return buffer;
}

//___________________________________________________________________
TObject* ODBCResultSet::GetObject( Int_t columnIndex )
{
   // Gets the value of a column in the current row as ROOT object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       TObject 
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   TObject* obj =0;

   TBuffer *b = GetBinaryStream(columnIndex);
   obj = (TObject *)b->ReadObjectAny(TObject::Class()); 
   // Laurent found that this causes a memory leak, Valeriy Onuchin never responded to this
   // b->DetachBuffer();
   delete b; 
   return obj;
}

//___________________________________________________________________
TString ODBCResultSet::GetString( const TString& columnName )
{
   // Gets the value of a column in the current row as a TString.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetString(FindColumn(columnName));
}

//___________________________________________________________________
Bool_t ODBCResultSet::GetBoolean( const TString& columnName )
{
   // Gets the value of a column in the current row as a boolean.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is kFALSE
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetBoolean(FindColumn(columnName));
}

//___________________________________________________________________
Char_t ODBCResultSet::GetByte( const TString& columnName )
{
   // Gets the value of a column in the current row as a Char_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetByte(FindColumn(columnName));
}

//___________________________________________________________________
Short_t ODBCResultSet::GetShort( const TString& columnName )
{
    // Gets the value of a column in the current row as a Short_t.
    // 
    // Parameters:
    //      columnName - the SQL name of the column
    // Returns:
    //      the column value; if the value is SQL NULL, 
    //      the result is 0
    // Throws:
    //      TSQLException - if a database access error occurs

   return GetShort(FindColumn(columnName));
}

//___________________________________________________________________
Int_t ODBCResultSet::GetInt( const TString& columnName )
{
   // Gets the value of a column in the current row as a Int_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetInt(FindColumn(columnName));
}

//___________________________________________________________________
Long_t ODBCResultSet::GetLong( const TString& columnName )
{
   // Gets the value of a column in the current row as a Long_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL,
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetLong(FindColumn(columnName));
}

//___________________________________________________________________
Float_t ODBCResultSet::GetFloat( const TString& columnName )
{
   // Gets the value of a column in the current row as a Float_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetFloat(FindColumn(columnName));
}

//___________________________________________________________________
Double_t ODBCResultSet::GetDouble( const TString& columnName )
{
   // Gets the value of a column in the current row as a Double_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetDouble(FindColumn(columnName));
}

//___________________________________________________________________
TArrayC ODBCResultSet::GetBytes( const TString& columnName )
{
   // Gets the value of a column in the current row as a char
   // array. The chars represent the raw values returned by the 
   // driver.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetBytes(FindColumn(columnName));
}

//___________________________________________________________________
TSQLDate ODBCResultSet::GetDate( const TString& columnName )
{
   // Gets the value of a column in the current row as a TSQLDate
   //  object.
   // 
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   return GetDate(FindColumn(columnName));
}

//___________________________________________________________________
TSQLTime ODBCResultSet::GetTime( const TString& columnName )
{
  // Gets the value of a column in the current row as a TSQLTime
  // object.
  //
  //   Parameters:
  //        columnName - the SQL name of the column
  //   Returns:
  //        the column value; if the value is SQL NULL,
  //        the result is null
  //   Throws:
  //        TSQLException - if a database access error occurs

  return GetTime(FindColumn(columnName)); 
}

//___________________________________________________________________
TSQLTimestamp ODBCResultSet::GetTimestamp( const TString& columnName )
{
   // Gets the value of a column in the current row as a
   // TSQLTimestamp object.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetTimestamp(FindColumn(columnName));
}

//___________________________________________________________________
TBuffer* ODBCResultSet::GetAsciiStream( const TString& columnName )
{
   // Gets the value of a column in the current row as a stream 
   // of ASCII characters. The value can then be read in chunks 
   // from the stream. This method is particularly suitable for 
   // retrieving large LONGVARCHAR values. The driver will do 
   // any necessary conversion from the database format into ASCII. 
   //
   //  Note: All the data in the returned stream must be read prior
   //    to getting the value of any other column. The next call to
   //    a  Get method implicitly closes the stream. Also, a stream 
   //    may return 0 when the method available is called whether 
   //    there is data available or not.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       TBuffer that delivers the database column 
   //       value as a stream of one char ASCII characters. If 
   //       the value is SQL NULL then the result is null.
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetAsciiStream(FindColumn(columnName));
}

//___________________________________________________________________
TBuffer* ODBCResultSet::GetBinaryStream( const TString& columnName )
{
   // Gets the value of a column in the current row as a stream of
   // uninterpreted chars. The value can then be read in chunks 
   // from the stream. This method is particularly suitable for
   // retrieving large LONGVARBINARY values. The driver will 
   // do any necessary conversion from the database format into 
   // uninterpreted chars. 
   //
   //  Note: All the data in the returned stream must be read 
   //    prior to getting the value of any other column. The next 
   //    call to a Get method implicitly closes the stream. Also, 
   //    a stream may return 0 when the method available is called 
   //    whether there is data available or not.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       TBuffer that delivers the database column 
   //       value as a stream of uninterpreted chars. If the value 
   //       is SQL NULL then the result is null.
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetBinaryStream(FindColumn(columnName));
}

//___________________________________________________________________
TObject* ODBCResultSet::GetObject( const TString& columnName )
{
   // Gets the value of a column in the current row as ROOT object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       TObject 
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   return GetObject(FindColumn(columnName));
}

//___________________________________________________________________
TString ODBCResultSet::GetCursorName()
{
   // Gets the name of the SQL cursor used by this TSQLResultSet. 
   //
   // In SQL, a result table is retrieved through a cursor that 
   // is named. The current row of a result can be updated or 
   // deleted using a positioned Update/Delete statement that 
   // references the cursor name. To insure that the cursor has 
   // the proper isolation level to support update, the cursor's 
   // select statement should be of the form 'SELECT FOR UPDATE'. 
   // If the 'FOR UPDATE' clause is omitted the positioned 
   // updates may fail. 
   //    The current row of a TSQLResultSet is also the current row 
   // of this SQL cursor. 
   //
   //  Note: If positioned update is not supported a 
   //       SQLException is thrown
   //  Returns:
   //       the TSQLResultSet's SQL cursor name
   //  Throws:
   //       TSQLException - if a database access error occurs

   TString str;
   
   if(!fImp) { Destroyed(); return str; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      str = ODBCXX_STRING_CSTR( rs->getCursorName() );

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return "";
   }
   return str;
}

//___________________________________________________________________
TSQLResultSetMetaData* ODBCResultSet::GetMetaData()
{
   // Retrieves the number, types and properties of a 
   // TSQLResultSet's columns.
   //
   //  Returns:
   //       the description of a TSQLResultSet's columns
   //  Throws:
   //       TSQLException - if a database access error occurs

   return fMetaData;
}

//___________________________________________________________________
Int_t ODBCResultSet::FindColumn( const TString& columnName )
{
   // Maps the given resultset column name to its TSQLResultSet
   // column index.
   //
   //  Parameters:
   //       columnName - the name of the column
   //  Returns:
   //       the column index
   //  Throws:
   //       TSQLException - if a database access error occurs

   Int_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try { 
      return_value = rs->findColumn( 
                                 ODBCXX_STRING_C(columnName.Data()) );

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Bool_t ODBCResultSet::IsBeforeFirst()
{
   // Indicates whether the cursor is before the first row in 
   // the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is before the first row, 
   //       kFALSE otherwise. Returns kFALSE when the
   //       result set contains no rows.
   //  Throws:
   //       TSQLException - if a database access error occurs

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->isBeforeFirst();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
Bool_t ODBCResultSet::IsAfterLast()
{
   // Indicates whether the cursor is after the last row in 
   // the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is after the last row, 
   //       kFALSE otherwise. Returns kFALSE when the
   //       result set contains no rows.
   //  Throws:
   //       TSQLException - if a database access error occurs

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {      
      return_value = rs->isAfterLast();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}
          
//___________________________________________________________________
Bool_t ODBCResultSet::IsFirst() 
{
   // Indicates whether the cursor is on the first row of 
   // the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is on the first row, 
   //       kFALSE otherwise.
   //  Throws:
   //       TSQLException - if a database access error occurs

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->isFirst();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
Bool_t ODBCResultSet::IsLast()
{
   // Indicates whether the cursor is on the last row of the 
   // result set.
   //
   //  Note: Calling the method IsLast() may be expensive because 
   //       the driver might need to fetch ahead one row in 
   //       order to determine whether the current row is the 
   //       last row in the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is on the last row, 
   //       kFALSE otherwise.
   //  Throws:
   //       TSQLException - if a database access error occurs

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      return_value = rs->isLast();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
void ODBCResultSet::BeforeFirst()
{
   // Moves the cursor to the front of the result set, just before 
   // the first row. Has no effect if the result set contains no 
   // rows.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {     
      rs->beforeFirst();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::AfterLast()
{
   // Moves the cursor to the end of the result set, just after 
   // the last row. Has no effect if the result set contains no 
   // rows.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY

   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {
      rs->afterLast();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
Int_t ODBCResultSet::GetRow()
{
   // Retrieves the current row number. The first row is number 1, 
   // the second number 2, and so on.
   //
   //  Returns:
   //       the current row number; 0 if there is no current row
   //  Throws:
   //       TSQLException - if a database access error occurs

   Int_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      return_value = rs->getRow();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
void ODBCResultSet::SetFetchDirection(Int_t /* direction */)
{
   // Gives a hint as to the direction in which the rows in this
   // result set will be processed. The initial value is determined
   // by the TSQLStatement that produced the result set.
   // The fetch direction may be changed at any time.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY and the fetch 
   //       direction is not forward

}

//___________________________________________________________________
Int_t ODBCResultSet::GetFetchDirection()
{
   // Returns the fetch direction for this result set.
   //
   //  Returns:
   //       the current fetch direction for this result set
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   return 0;   // not applied
}

//___________________________________________________________________
void ODBCResultSet::SetFetchSize(Int_t rows)
{
   // Gives the driver a hint as to the number of rows that
   // should be fetched from the database when more rows are needed 
   // for this result set. If the fetch size specified is zero, 
   // the driver ignores the value and is free to make its own
   // best guess as to what the fetch size should be. The default 
   // value is set by the statement that created the result set. 
   // The fetch size may be changed at any time.
   //
   //  Parameters:
   //       rows - the number of rows to fetch
   //  Throws:
   //       TSQLException - if a database access error occurs or the
   //       condition 0 <= rows <= GetMaxRows() is not satisfied.
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->setFetchSize(rows);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
Int_t ODBCResultSet::GetFetchSize()
{
   // Returns the fetch size for this result set.
   //
   //  Returns:
   //       the current fetch size for this result set
   //  Throws:
   //       TSQLException - if a database access error occurs

   Int_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->getFetchSize();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Int_t ODBCResultSet::GetType()
{
   // Returns the type of this result set. The type is
   // determined by the TSQLStatement that created the result set.
   //
   //  Returns:
   //       kTYPE_FORWARD_ONLY, kTYPE_SCROLL_INSENSITIVE, or
   //       kTYPE_SCROLL_SENSITIVE
   //  Throws:
   //       TSQLException - if a database access error occurs

   Int_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {     
      return_value = rs->getType();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Int_t ODBCResultSet::GetConcurrency()
{
   // Returns the concurrency mode of this result set. The
   // concurrency used is determined by the TSQLStatement that 
   // created the result set.
   //
   //  Returns:
   //       the concurrency type, kCONCUR_READ_ONLY or 
   //                             kCONCUR_UPDATABLE
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   Int_t return_value = 0;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {      
      return_value = rs->getConcurrency();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value;
}

//___________________________________________________________________
Bool_t ODBCResultSet::RowUpdated()
{
   // Indicates whether the current row has been updated. The
   // value returned depends on whether or not the result set 
   // can detect updates.
   //
   //  Returns:
   //       kTRUE if the row has been visibly updated by 
   //       the owner or another, and updates are detected
   //  Throws:
   //       TSQLException - if a database access error occurs
   //  See Also: 
   //       TSQLDatabaseMetaData::updatesAreDetected(Int_t)

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {
      return_value = rs->rowUpdated();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
Bool_t ODBCResultSet::RowInserted()
{
   // Indicates whether the current row has had an insertion.
   //  The value returned depends on whether or not the 
   // result set can detect visible inserts.
   //
   //  Returns:
   //       kTRUE if a row has had an insertion and insertions 
   //       are detected
   //  Throws:
   //       TSQLException - if a database access error occurs
   //  See Also: 
   //       TSQLDatabaseMetaData::insertsAreDetected(Int_t)

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      return_value = rs->rowInserted();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
Bool_t ODBCResultSet::RowDeleted()
{
   // Indicates whether a row has been deleted. A deleted row
   // may leave a visible "hole" in a result set. This method 
   // can be used to detect holes in a result set. The value 
   // returned depends on whether or not the result set can 
   // detect deletions.
   //
   //  Returns:
   //       kTRUE if a row was deleted and deletions are detected
   //  Throws:
   //       TSQLException - if a database access error occurs
   //  See Also: 
   //       TSQLDatabaseMetaData::deletesAreDetected(Int_t)

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return return_value; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {
      return_value = rs->rowDeleted();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = kFALSE;
   }
   return return_value;
}

//___________________________________________________________________
void ODBCResultSet::UpdateNull( Int_t columnIndex )
{
   // Give a nullable column a null value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->updateNull(columnIndex);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateBoolean( Int_t columnIndex,Bool_t x )
{
   // Updates a column with a boolean value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->updateBoolean(columnIndex,x);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateByte( Int_t columnIndex,Char_t x )
{
   // Updates a column with a Char_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->updateByte(columnIndex,x);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateShort( Int_t columnIndex,Short_t x )
{
   // Updates a column with a Short_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->updateShort(columnIndex,x);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateInt( Int_t columnIndex,Int_t x )
{
   // Updates a column with an integer value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      rs->updateInt(columnIndex,x);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateLong( Int_t columnIndex,Long_t x )
{
   // Updates a column with a Long_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      rs->updateLong(columnIndex,x);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateFloat( Int_t columnIndex,Float_t x )
{
   // Updates a column with a Float_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      rs->updateFloat(columnIndex,x);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateDouble( Int_t columnIndex,
                                  Double_t x )
{
   // Updates a column with a Double value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->updateDouble(columnIndex,x);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateString( Int_t columnIndex,
                                  const TString& x )
{
   // Updates a column with a TString value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {       
      ODBCXX_STRING s = ODBCXX_STRING_C(x.Data()); 
      rs->updateString(columnIndex,s);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateBytes( Int_t columnIndex,
                                 const TArrayC& x )
{
   // Updates a column with a Char_t array value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      ODBCXX_BYTES b = ODBCXX_BYTES_C(x.GetArray(),x.GetSize());
      rs->updateBytes(columnIndex,b);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateDate( Int_t columnIndex,
                                const TSQLDate& x )
{
   // Updates a column with a TSQLDate value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      odbc::Date dt( x.GetYear(),
                     x.GetMonth(),
                     x.GetDay() );
    
      rs->updateDate(columnIndex,dt);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateTime( Int_t columnIndex,
                                const TSQLTime& x )
{
   // Updates a column with a TSQLTime value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try { 
      odbc::Time tm( x.GetHour(),
                     x.GetMinute(),
                     x.GetSecond() );
   
      rs->updateTime(columnIndex,tm);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateTimestamp( Int_t columnIndex,
                                     const TSQLTimestamp& x )
{
   // Updates a column with a TSQLTimestamp value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try { 
      odbc::Timestamp tmstmp( x.GetYear(),
                              x.GetMonth(),
                              x.GetDay(),  
                              x.GetHour(),
                              x.GetMinute(),
                              x.GetSecond(),
                              x.GetNanos() );
   
      rs->updateTimestamp(columnIndex,tmstmp);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateAsciiStream( Int_t columnIndex,
                                       TBuffer* x,
                                       Int_t length )
{
   // Updates a column with an ascii stream value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs  

   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {         
      Int_t xl = (x->BufferSize()>length) && (length>0) ? length : x->BufferSize();
      std::istringstream* s = new std::istringstream(x->Buffer()); //
      rs->updateAsciiStream( columnIndex,(std::istream*)s,xl );
      
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateBinaryStream( Int_t columnIndex,
                                        TBuffer* x,
                                        Int_t length )
{
   // Updates a column with a binary stream value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream   
   //  Throws:
   //       TSQLException - if a database access error occurs

   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {   
      Int_t xl = (x->BufferSize()>length) && (length>0) ? length : x->BufferSize();
      std::istringstream* s = new std::istringstream(x->Buffer());
      rs->updateBinaryStream( columnIndex,(std::istream*)s,xl );
      
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateObject( Int_t columnIndex,TObject* x )
{
   // Updates a column with a ROOT object. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream   
   //  Throws:
   //       TSQLException - if a database access error occurs
 
#if ROOT_VERSION_CODE >= ROOT_VERSION(5,15,0)
  TBuffer *b = new TBufferFile(TBuffer::kWrite);
#else
  TBuffer *b = new TBuffer(TBuffer::kWrite);
#endif
   b->WriteObject(x);
   UpdateBinaryStream(columnIndex,b,b->BufferSize());
   b->DetachBuffer();
   delete b; 
}

//___________________________________________________________________
void ODBCResultSet::UpdateNull( const TString& columnName )
{
   // Updates a column with a null value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateNull(FindColumn(columnName));
}

//___________________________________________________________________
void ODBCResultSet::UpdateBoolean( const TString& columnName,Bool_t x )
{
   // Updates a column with a boolean value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateBoolean(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateByte( const TString& columnName,Char_t x )
{
   // Updates a column with a Char_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateByte(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateShort( const TString& columnName,Short_t x )
{
   // Updates a column with a short value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateShort(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateInt( const TString& columnName,Int_t x )
{
   // Updates a column with an integer value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateInt(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateLong( const TString& columnName,Long_t x )
{
   // Updates a column with a long value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateLong(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateFloat( const TString& columnName,Float_t x )
{
   // Updates a column with a float value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 

   UpdateFloat(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateDouble( const TString& columnName,Double_t x )
{
   // Updates a column with a double value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateDouble(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateString( const TString& columnName,
                                  const TString& x )
{
   // Updates a column with a TString value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateString(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateBytes( const TString& columnName,
                                 const TArrayC& x )
{
   // Updates a column with a bytes array value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 

   UpdateBytes(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateDate( const TString& columnName,
                                const TSQLDate& x )
{
   // Updates a column with a TSQLDate value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 

   UpdateDate(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateTime( const TString& columnName,
                                const TSQLTime& x )
{
   // Updates a column with a TSQLTime value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 
   
   UpdateTime(FindColumn(columnName),x);
}

//___________________________________________________________________
void ODBCResultSet::UpdateTimestamp( const TString& columnName,
                                     const TSQLTimestamp& x )
{
   // Updates a column with a TSQLTimestamp value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   UpdateTimestamp(FindColumn(columnName),x);
}   

//___________________________________________________________________
void ODBCResultSet::UpdateAsciiStream( const TString& columnName,
                                       TBuffer* x,
                                       Int_t length )
{
   // Updates a column with an ascii stream value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateAsciiStream(FindColumn(columnName),x,length);
}

//___________________________________________________________________
void ODBCResultSet::UpdateBinaryStream( const TString& columnName,
                                        TBuffer* x,
                                        Int_t length )
{
   // Updates a column with a binary stream value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   UpdateBinaryStream(FindColumn(columnName),x,length); 
}

//___________________________________________________________________
void ODBCResultSet::UpdateObject(const TString& columnName,TObject* x)
{
   // Updates a column with a ROOT object. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   UpdateObject(FindColumn(columnName),x); 
}

//___________________________________________________________________
void ODBCResultSet::InsertRow()
{
   // Inserts the contents of the insert row into the result set
   // and the database. Must be on the insert row when this method
   // is called.
   //
   //  Throws:
   //     TSQLException - if a database access error occurs, if 
   //     called when not on the insert row, or if not all of 
   //     non-nullable columns in the insert row have been given 
   //     a value.

   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;

   try {
      rs->insertRow();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::UpdateRow()
{
   // Updates the underlying database with the new contents of
   // the current row. Cannot be called when on the insert row.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or if
   //       called when on the insert row

   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->updateRow();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::DeleteRow()
{
   // Deletes the current row from the result set and the underlying 
   // database. Cannot be called when on the insert row.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       if called when on the insert row.
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->deleteRow();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::RefreshRow()
{
   // Refreshes the current row with its most recent value in
   // the database. Cannot be called when on the insert row. 
   // The RefreshRow() method provides a way for an application to
   // explicitly tell the driver to refetch a row(s) from the
   // database. An application may want to call RefreshRow() when 
   // caching or prefetching is being done by the driver to
   // fetch the latest value of a row from the database. The 
   // driver may actually refresh multiple rows at once if the 
   // fetch size is greater than one. All values are refetched
   // subject to the transaction isolation level and cursor 
   // sensitivity. If RefreshRow() is called after calling UpdateXXX,
   // but before calling UpdateRow(), then the updates made to the 
   // row are lost. Calling the method RefreshRow() frequently will 
   // likely slow performance.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       if called when on the insert row
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->refreshRow();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::CancelRowUpdates()
{
   // Cancels the updates made to a row. This method may be
   // called after calling an UpdateXXX method(s) and before 
   // calling UpdateRow() to rollback the updates made to a row. 
   // If no updates have been made or UpdateRow() has already been 
   // called then this method has no effect.
   //
   //   Throws:
   //        TSQLException - if a database access error occurs or if 
   //         called when on the insert row
  
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      rs->cancelRowUpdates();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::MoveToInsertRow()
{
   //  Moves the cursor to the insert row. The current cursor
   //  position is remembered while the cursor is positioned on 
   //  the insert row. The insert row is a special row associated 
   //  with an updatable result set. It is essentially a buffer 
   //  where a new row may be constructed by calling the UpdateXXX 
   //  methods prior to inserting the row into the result set. 
   //  Only the UpdateXXX, GetXXX, and InsertRow() methods may be 
   //  called when the cursor is on the insert row.
   //  All of the columns in a result set must be given a value 
   //  each time this method is called before calling InsertRow(). 
   //  The method UpdateXXX must be called before a GetXXX method 
   //  can be called on a column value.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs 
   //       or the result set is not updatable
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      rs->moveToInsertRow();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
void ODBCResultSet::MoveToCurrentRow()
{
   // Moves the cursor to the remembered cursor position,
   // usually the current row. This method has no effect if the 
   // cursor is not on the insert row.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set is not updatable
   
   if(!fImp) { Destroyed(); return; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      rs->moveToCurrentRow();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
}

//___________________________________________________________________
TSQLRow* ODBCResultSet::Next()
{
   // Moves the cursor down one row from its current position. A
   // TSQLResultSet cursor is initially positioned before the first 
   // row; the first call to next makes the first row the current 
   // row; the second call makes the second row the current row, 
   // and so on.
   // 
   // If an input stream is open for the current row, a call to the
   // method next will implicitly close it. The TSQLResultSet's 
   // warning chain is cleared when a new row is read.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE) if the new current row is valid; 
   //       null(kFALSE) if there are no more rows
   //  Throws:
   //       TSQLException - if a database access error occurs

   Bool_t return_value=kFALSE;
   
   if(!fImp) { Destroyed(); return 0; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->next();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value ? fRow->Set(this) : 0;
}

//___________________________________________________________________
TSQLRow* ODBCResultSet::First()
{
   // Moves the cursor to the first row in the result set.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a valid row; 
   //       null(kFALSE) if there are no rows in the result set
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY


   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return 0; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {      
      return_value = rs->first();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value  ? fRow->Set(this) : 0;
}

//___________________________________________________________________
TSQLRow* ODBCResultSet::Absolute( Int_t row )
{
   // Moves the cursor to the given row number in the result set. 
   // If the row number is positive, the cursor moves to the 
   // given row number with respect to the beginning of the 
   // result set. The first row is row 1, the second is row 2, 
   // and so on. 
   //
   //  If the given row number is negative, the cursor moves to an
   // absolute row position with respect to the end of the result 
   // set. For example, calling Absolute(-1) positions the cursor
   // on the last row, Absolute(-2) indicates the next-to-last row, 
   // and so on. 
   //
   //  An attempt to position the cursor beyond the first/last row 
   // in the result set leaves the cursor before/after the first/last
   // row, respectively. 
   //
   //  Note: calling Absolute(1) is the same as calling First(). 
   //        calling Absolute(-1) is the same as calling Last().
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on the result set; 
   //       null(kFALSE) otherwise
   //  Throws:
   //       TSQLException - if a database access error occurs or
   //       row is 0, or result set type is kTYPE_FORWARD_ONLY

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return 0; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {     
      return_value = rs->absolute(row); 
   
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value  ? fRow->Set(this) : 0;
}

//___________________________________________________________________
TSQLRow* ODBCResultSet::Relative(Int_t rows)
{
   // Moves the cursor a relative number of rows, either positive or
   // negative. Attempting to move beyond the first/last row in 
   // the result set positions the cursor before/after the the
   // first/last row. Calling Relative(0) is valid, but does not 
   // change the cursor position. 
   //
   //  Note: Calling Relative(1) is different from calling Next() 
   //       because is makes sense to call Next() when there is 
   //       no current row, for example, when the cursor is 
   //       positioned before the first row or after the last row
   //       of the result set.
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a row; 
   //       null(kFALSE) otherwise
   //  Throws:
   //       TSQLException - if a database access error occurs, 
   //       there is no current row, or the result set type 
   //       is kTYPE_FORWARD_ONLY

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return 0; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
   
   try {
      return_value = rs->relative(rows);

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value  ? fRow->Set(this) : 0;
}

//___________________________________________________________________
TSQLRow* ODBCResultSet::Previous()
{
   // Moves the cursor to the previous row in the result set. 
   //
   //  Note: Previous() is not the same as Relative(-1)
   //       because it makes sense to call Previous()
   //       when there is no current row.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a valid row; 
   //       null(kFALSE) if it is off the result set
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return 0; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {
      return_value = rs->previous(); 
  
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value  ? fRow->Set(this) : 0;   
}

//___________________________________________________________________
TSQLRow* ODBCResultSet::Last()
{
   // Moves the cursor to the last row in the result set.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a valid row; 
   //       null(kFALSE) if there are norows in the result set
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY

   Bool_t return_value = kFALSE;
   
   if(!fImp) { Destroyed(); return 0; }
   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
      
   try {     
      return_value = rs->last();

   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
      return_value = 0;
   }
   return return_value  ? fRow->Set(this) : 0;
}

//___________________________________________________________________
void ODBCResultSet::Close(Option_t * /* option */)
{
   // Releases this TSQLResultSet object's database and resources
   // immediately instead of waiting for this to happen when it is 
   // automatically closed. 
   //
   // Note: A TSQLResultSet is automatically closed by the 
   // statement that generated it when that statement 
   // is closed, re-executed, or is used to retrieve the next
   // result from a sequence of multiple results. A TSQLResultSet 
   // is also automatically closed when it is garbage collected.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs
  
   if(!fImp) { Destroyed(); return; }

   try {       
      if(fMetaData) delete ((ODBCResultSetMetaData*)fMetaData); 
      if(fRow) delete fRow; 

      if(fImp) {
         odbc::ResultSet* imp = (odbc::ResultSet*)fImp;  
         delete  imp;
      }
   } catch(odbc::SQLException& e) {
      Throw( new TSQLException( ODBCXX_STRING_CSTR(e.getMessage()),
                                ODBCXX_STRING_CSTR(e.getSQLState()),
                                e.getErrorCode()) );
   }
   
   fMetaData = 0;   
   fRow = 0;
   fImp = 0;
   Destroyed();
}
