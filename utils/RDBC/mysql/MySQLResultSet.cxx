// $Id: MySQLResultSet.cxx,v 1.1.1.1 2004/02/18 20:58:02 dave Exp $
//*-- Author : Valeriy Onuchin 26/02/2001 
//
// RDBC driver to MySQL database implemented with MySQL C API.
//
// ++ The code consists of some parts stolen from mm JDBC and  
//    MyODBC ODBC drivers and other mysql-related open sources.
//

//
/////////////////////////////////////////////////////////////////////
//
// A TSQLResultSet provides access to a table of data. A 
// TSQLResultSet object is usually generated by executing 
// TSQLStatement. 
//
// A TSQLResultSet maintains a cursor pointing to its current row 
// of data. Initially the cursor is positioned before the first
// row. The Next() method moves the cursor to the next row. 
//
// The GetXXX methods retrieve column values for the current row.
// You can retrieve values using either the index number of the 
// column or the name of the column. In general,using the column 
// index will be more efficient. Columns are numbered from 1. 
//
// For maximum portability, TSQLResultSet columns within each row
// should be read in left-to-right order and each column should be 
// read only once. 
//
// For the GetXXX methods, the driver attempts to convert the
// underlying data to the specified ROOT type and returns a suitable 
// value. See the specification for allowable mappings 
// from SQL types to ROOT types with the TSQLResultSet::GetXXX 
// methods. 
//
// Column names used as input to GetXXX methods are case
// insensitive. When performing a GetXXX using a column name, 
// if several columns have the same name, then the value of the 
// first matching column will be returned. The column name option 
// is designed to be used when column names are used in the SQL 
// query. For columns that are NOT explicitly named in the query, 
// it is best to use column numbers. If column names are used, there 
// is no way for the programmer to guarantee that they actually refer 
// to the intended columns. 
//
// A TSQLResultSet is automatically closed by the TSQLStatement that 
// generated it when that TSQLStatement is closed, re-executed, 
// or used  to retrieve the next result from a sequence of multiple 
// results. 
//
// The number, types and properties of a TSQLResultSet's columns are
// provided by the TSQLResulSetMetaData object returned by the 
// GetMetaData() method. 
//
// See also: 
//      TSQLStatement::ExecuteQuery(const TString&),
//      TSQLStatement::GetResultSet(), TSQLResultSetMetaData
//
//___________________________________________________________________
//
//       kCONCUR_READ_ONLY 
//
// The concurrency mode for a TSQLResultSet object that may 
// NOT be updated.
//___________________________________________________________________
//
//       kCONCUR_UPDATABLE 
//
//  The concurrency mode for a TSQLResultSet
//  object that may be updated.
//___________________________________________________________________
//
//       kFETCH_FORWARD 
//
// The rows in a result set will be
// processed in a forward direction; first-to-last.
//___________________________________________________________________
//
//       kFETCH_REVERSE 
//
// The rows in a result set will be
// processed in a reverse direction; last-to-first.
//___________________________________________________________________
//
//       kFETCH_UNKNOWN 
//
// The order in which rows in a result set
// will be processed is unknown.
//___________________________________________________________________
//
//       kTYPE_FORWARD_ONLY 
//
// The type for a TSQLResultSet object whose
// cursor may move only forward.
//___________________________________________________________________
//
//       kTYPE_SCROLL_INSENSITIVE 
//
// The type for a TSQLResultSet object that is
// scrollable but generally not sensitive to changes made by
// others.
//___________________________________________________________________
//
//       kTYPE_SCROLL_SENSITIVE 
// 
// The type for a TSQLResultSet object that is
// scrollable and generally sensitive to changes made by
// others.
//
/////////////////////////////////////////////////////////////////////
 
#include <RDBC/TSQLResultSet.h>
#include <RDBC/TSQLResultSetMetaData.h>
#include <RDBC/TSQLStatement.h>
#include <TList.h>
#include <TMath.h>
#include <TStopwatch.h>
#include <TBuffer.h>
#include <TTree.h>
#include <TRandom.h>
#include <TBranch.h>
#include <iostream>
#include <sstream>
#include <ctype.h>
#include <time.h>

#include <TSQLRow.h>
#include "MySQLResultSetPrivate.h"

ClassImpQ(TSQLResultSet)

/////////////////////////////////////////////////////////////////////
//
// MySQLRow rewritten from TMySQLRow
//
/////////////////////////////////////////////////////////////////////
class MySQLRow: public TSQLRow
{
friend  class TSQLResultSet;

private:

   MYSQL_RES   *fResult;       // current result set
   MYSQL_ROW    fFields;       // current row
   ULong_t     *fFieldLength;  // length of each field in the row

   MySQLRow(void *res) 
   { 
      fResult      = (MYSQL_RES *) res;
      fFields      = (MYSQL_ROW)fResult->current_row;
      fFieldLength = 0;     
   }

   MySQLRow* Set(void *res) 
   { 
      fResult      = (MYSQL_RES *) res;
      fFields      = (MYSQL_ROW)fResult->current_row;
      fFieldLength = 0;
      return this;
   }

   virtual ~MySQLRow() 
   {    
      if(fFields) Close(); 
   }

   void  Close(Option_t *opt="") 
   {
      // Close row.
   
      if (!fFields) return;

      fFields      = 0;
      fResult      = 0;
      fFieldLength = 0;        
   }
   
   Bool_t IsValid(Int_t field)
   {
      // Check if row is open and field index within range.
   
      if (!fFields) {
         // Error("IsValid", "row closed");
         return kFALSE;
      }
   
      if (field < 0 || field >= (Int_t)mysql_num_fields(fResult)) {
         //Error("IsValid", "field index out of bounds");
         return kFALSE;
      }
      return kTRUE;
   }

   ULong_t GetFieldLength(Int_t field) 
   {
      // Get length in bytes of specified field.
   
      if (!IsValid(field)) return 0;

      if (!fFieldLength)
         fFieldLength = mysql_fetch_lengths(fResult);
   
      if (!fFieldLength) {
//         Error("GetFieldLength", "cannot get field length");
         return 0;
      }

      return fFieldLength[field];      
   }

   const char* GetField(Int_t field)
   {
      // Get specified field from row (0 <= field < GetFieldCount()).

      if (!IsValid(field)) return 0;

      return fFields[field];
   }   
}; 

/////////////////////////////////////////////////////////////////////
//___________________________________________________________________
TSQLResultSet::TSQLResultSet(TSQLStatement* stmt,void* imp):TSQL(imp)
{
   // ctor
   
   fStatement = stmt;
   MySQLResultSetPrivate* pd = (MySQLResultSetPrivate*)fImp;
   fRow = new RDBCRow(pd->fMYSQL_RES);
   fMetaData = 0; // create it later, when TSQLResultSet::GetMetaData()
} 

//___________________________________________________________________
TSQLResultSet::~TSQLResultSet()
{
   // destructor. 

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(fMetaData) delete fMetaData;
   if(fRow) delete fRow;
   if(imp) delete imp;

   Destroyed();
}

//___________________________________________________________________
Bool_t TSQLResultSet::WasNull()
{
   // Reports whether the last column read had a value of SQL NULL. 
   // Note that you must first call GetXXX on a column to try to 
   // read its value and then call WasNull() to see if the value 
   // read was SQL NULL.
   //
   // Returns:
   //       kTRUE if last column read was SQL NULL and 
   //       kFALSE - otherwise
   //  Throws:
   //       TSQLException - if a database access error occurs
 
   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   return imp->fWasNull;
}

//___________________________________________________________________
TString TSQLResultSet::GetString( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a TString.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, the result 
   //       is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return "";
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return "";
   }

   return imp->fMYSQL_RES->current_row[columnIndex-1];
}

//___________________________________________________________________
Bool_t TSQLResultSet::GetBoolean( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a boolean.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, the result is
   //       kFALSE
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002",));
      return kFALSE;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return kFALSE;
   }

   const char* str = imp->fMYSQL_RES->current_row[columnIndex-1];
   
   return ( str && strlen(str) ) ?
            (str[0] == 't') || (str[0] == 'T') ||
            (str[0] == 'y') || (str[0] == 'Y') ||
            (str[0] == '1') || (str[0] == '1')  :  kFALSE;  
}

//___________________________________________________________________
Char_t TSQLResultSet::GetByte( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a byte.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   Char_t return_value = 0;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return 0;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return 0;
   }
 
   const char* str = imp->fMYSQL_RES->current_row[columnIndex-1];
  
   switch( imp->MYSQL_RES->fields[column-1].type ) {
   case FIELD_TYPE_DECIMAL:
   case FIELD_TYPE_TINY:
   case FIELD_TYPE_SHORT:
   case FIELD_TYPE_LONG:
   case FIELD_TYPE_FLOAT:
   case FIELD_TYPE_DOUBLE:
   case FIELD_TYPE_LONGLONG:
   case FIELD_TYPE_INT24:
      return (Char_t)atoi(str);
   default:
      return str[0];
   } 
   return 0;  // not reached   
}

//___________________________________________________________________
Short_t TSQLResultSet::GetShort( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Short_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return 0;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return 0;
   }

   return (Short_t)atoi(imp->fMYSQL_RES->current_row[columnIndex-1]);
}

//___________________________________________________________________
Int_t TSQLResultSet::GetInt( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Int_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return 0;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return 0;
   }
 
   return (Int_t)atoi(imp->fMYSQL_RES->current_row[columnIndex-1]);
}

//___________________________________________________________________
Long_t TSQLResultSet::GetLong( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Long_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return 0;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return 0;
   }
 
   char* value = imp->fMYSQL_RES->current_row[columnIndex-1];
   Int_t length = strlen(value);
  
   // .... MyDOBC says "Check if it could be a date...... :)"  

   if( length >= 10 && value[4] == '-' && value[7] == '-' && (!value[10] || value[10] == ' ') ) {
      return ((Long_t) atol(value)*10000L+(Long_t) atol(value+5)*100L+(Long_t) atol(value+8));
   } else {
      return (Long_t)atol(value);
   }
}  

//___________________________________________________________________
Float_t TSQLResultSet::GetFloat( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Float_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return 0;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return 0;
   }
 
   return (Float_t)atof(imp->fMYSQL_RES->current_row[columnIndex-1]);
}

//___________________________________________________________________
Double_t TSQLResultSet::GetDouble( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a Double_t.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return 0;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return 0;
   }
 
   return (Double_t)atof(imp->fMYSQL_RES->current_row[columnIndex-1]);
}

//___________________________________________________________________
TArrayC TSQLResultSet::GetBytes( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a char array.
   // The chars represent the raw values returned by the driver.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs
 
   TArrayC array;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return array;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return array;
   }

   return array;
}

//___________________________________________________________________
TSQLDate TSQLResultSet::GetDate( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a TSQLDate
   // object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   TSQLDate return_value;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return ;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return ;
   }
 
   return return_value;
}

//___________________________________________________________________
TSQLTime TSQLResultSet::GetTime( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a TSQLTime
   // object.
   //
   // Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   TSQLTime return_value;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return ;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return ;
   }
 
   return return_value;
}

//___________________________________________________________________
TSQLTimestamp TSQLResultSet::GetTimestamp( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a
   // TSQLTimestamp object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   TSQLTimestamp return_value;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return ;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return ;
   }

   return return_value;
}

//___________________________________________________________________
TBuffer* TSQLResultSet::GetAsciiStream( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a stream 
   // of ASCII characters. The value can then be read in chunks from 
   // the stream. This method is particularly suitable for 
   // retrieving large LONGVARCHAR values. The driver will do 
   // any necessary conversion from the database format into ASCII. 
   //
   //  Note: All the data in the returned stream must be read prior 
   //    to getting the value of any other column. The next call to 
   //    a get method implicitly closes the stream. Also, a stream 
   //    may return 0 when the method available is called whether 
   //    there is data available or not.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       A TBuffer that delivers the database column 
   //       value as a stream of one char ASCII characters. 
   //       If the value is SQL NULL then the result is null.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs

   TBuffer* buffer = 0;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return buffer;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return buffer;
   }
 
   return buffer;
}

//___________________________________________________________________
TBuffer* TSQLResultSet::GetBinaryStream( Int_t columnIndex )
{
   // Gets the value of a column in the current row as a stream of
   // uninterpreted chars. The value can then be read in chunks 
   // from the stream. This method is particularly suitable for
   //  retrieving large LONGVARBINARY values. 
   //
   //  Note: All the data in the returned stream must be read 
   //    prior to getting the value of any other column. The next 
   //    call to a Get method implicitly closes the stream. Also, 
   //    a stream may return 0 when the method available is called 
   //    whether there is data available or not.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       TBuffer that delivers the database column 
   //       value as a stream of uninterpreted chars. If the value 
   //       is SQL NULL then the result is null.
   //  Throws:
   //       TSQLException - if a database access error occurs

   TBuffer* buffer = 0;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return buffer;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return buffer;
   }
 
   return buffer;
}

//___________________________________________________________________
TObject* TSQLResultSet::GetObject( Int_t columnIndex )
{
   // Gets the value of a column in the current row as ROOT object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       TObject 
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   TObject* obj =0;

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if(!imp->fMYSQL_RES->field_count) {
      Throw(new TSQLException("Query generated no fields for ResultSet", "S1002"));
      return obj;
   }

   if( (UInt_t)(columnIndex-1) >= imp->fMYSQL_RES->field_count ) {
      Throw(new TSQLException(Form("Invalid column number ( %d > %d )",columnIndex,imp->fMYSQL_RES->field_count+1),"S1002",);
      return obj;
   }

   TBuffer *b = GetBinaryStream(columnIndex);
   obj = b->ReadObject(TObject::Class()); 
   b->DetachBuffer();
   delete b; 
   return obj;
}

//___________________________________________________________________
TString TSQLResultSet::GetString( const TString& columnName )
{
   // Gets the value of a column in the current row as a TString.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetString(FindColumn(columnName));
}

//___________________________________________________________________
Bool_t TSQLResultSet::GetBoolean( const TString& columnName )
{
   // Gets the value of a column in the current row as a boolean.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is kFALSE
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetBoolean(FindColumn(columnName));
}

//___________________________________________________________________
Char_t TSQLResultSet::GetByte( const TString& columnName )
{
   // Gets the value of a column in the current row as a Char_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetByte(FindColumn(columnName));
}

//___________________________________________________________________
Short_t TSQLResultSet::GetShort( const TString& columnName )
{
    // Gets the value of a column in the current row as a Short_t.
    // 
    // Parameters:
    //      columnName - the SQL name of the column
    // Returns:
    //      the column value; if the value is SQL NULL, 
    //      the result is 0
    // Throws:
    //      TSQLException - if a database access error occurs

   return GetShort(FindColumn(columnName));
}

//___________________________________________________________________
Int_t TSQLResultSet::GetInt( const TString& columnName )
{
   // Gets the value of a column in the current row as a Int_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetInt(FindColumn(columnName));
}

//___________________________________________________________________
Long_t TSQLResultSet::GetLong( const TString& columnName )
{
   // Gets the value of a column in the current row as a Long_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL,
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetLong(FindColumn(columnName));
}

//___________________________________________________________________
Float_t TSQLResultSet::GetFloat( const TString& columnName )
{
   // Gets the value of a column in the current row as a Float_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetFloat(FindColumn(columnName));
}

//___________________________________________________________________
Double_t TSQLResultSet::GetDouble( const TString& columnName )
{
   // Gets the value of a column in the current row as a Double_t.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is 0
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetDouble(FindColumn(columnName));
}

//___________________________________________________________________
TArrayC TSQLResultSet::GetBytes( const TString& columnName )
{
   // Gets the value of a column in the current row as a char
   // array. The chars represent the raw values returned by the 
   // driver.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetBytes(FindColumn(columnName));
}

//___________________________________________________________________
TSQLDate TSQLResultSet::GetDate( const TString& columnName )
{
   // Gets the value of a column in the current row as a TSQLDate
   //  object.
   // 
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   return GetDate(FindColumn(columnName));
}

//___________________________________________________________________
TSQLTime TSQLResultSet::GetTime( const TString& columnName )
{
  // Gets the value of a column in the current row as a TSQLTime
  // object.
  //
  //   Parameters:
  //        columnName - the SQL name of the column
  //   Returns:
  //        the column value; if the value is SQL NULL,
  //        the result is null
  //   Throws:
  //        TSQLException - if a database access error occurs

  return GetTime(FindColumn(columnName)); 
}

//___________________________________________________________________
TSQLTimestamp TSQLResultSet::GetTimestamp( const TString& columnName )
{
   // Gets the value of a column in the current row as a
   // TSQLTimestamp object.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       the column value; if the value is SQL NULL, 
   //       the result is null
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetTimestamp(FindColumn(columnName));
}

//___________________________________________________________________
TBuffer* TSQLResultSet::GetAsciiStream( const TString& columnName )
{
   // Gets the value of a column in the current row as a stream 
   // of ASCII characters. The value can then be read in chunks 
   // from the stream. This method is particularly suitable for 
   // retrieving large LONGVARCHAR values. The driver will do 
   // any necessary conversion from the database format into ASCII. 
   //
   //  Note: All the data in the returned stream must be read prior
   //    to getting the value of any other column. The next call to
   //    a  Get method implicitly closes the stream. Also, a stream 
   //    may return 0 when the method available is called whether 
   //    there is data available or not.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       TBuffer that delivers the database column 
   //       value as a stream of one char ASCII characters. If 
   //       the value is SQL NULL then the result is null.
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetAsciiStream(FindColumn(columnName));
}

//___________________________________________________________________
TBuffer* TSQLResultSet::GetBinaryStream( const TString& columnName )
{
   // Gets the value of a column in the current row as a stream of
   // uninterpreted chars. The value can then be read in chunks 
   // from the stream. This method is particularly suitable for
   // retrieving large LONGVARBINARY values. The driver will 
   // do any necessary conversion from the database format into 
   // uninterpreted chars. 
   //
   //  Note: All the data in the returned stream must be read 
   //    prior to getting the value of any other column. The next 
   //    call to a Get method implicitly closes the stream. Also, 
   //    a stream may return 0 when the method available is called 
   //    whether there is data available or not.
   //
   //  Parameters:
   //       columnName - the SQL name of the column
   //  Returns:
   //       TBuffer that delivers the database column 
   //       value as a stream of uninterpreted chars. If the value 
   //       is SQL NULL then the result is null.
   //  Throws:
   //       TSQLException - if a database access error occurs

   return GetBinaryStream(FindColumn(columnName));
}

//___________________________________________________________________
TObject* TSQLResultSet::GetObject( const TString& columnName )
{
   // Gets the value of a column in the current row as ROOT object.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Returns:
   //       TObject 
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   return GetObject(FindColumn(columnName));
}

//___________________________________________________________________
TString TSQLResultSet::GetCursorName()
{
   // Gets the name of the SQL cursor used by this TSQLResultSet. 
   //
   // In SQL, a result table is retrieved through a cursor that 
   // is named. The current row of a result can be updated or 
   // deleted using a positioned Update/Delete statement that 
   // references the cursor name. To insure that the cursor has 
   // the proper isolation level to support update, the cursor's 
   // select statement should be of the form 'SELECT FOR UPDATE'. 
   // If the 'FOR UPDATE' clause is omitted the positioned 
   // updates may fail. 
   //    The current row of a TSQLResultSet is also the current row 
   // of this SQL cursor. 
   //
   //  Note: If positioned update is not supported a 
   //       SQLException is thrown
   //  Returns:
   //       the TSQLResultSet's SQL cursor name
   //  Throws:
   //       TSQLException - if a database access error occurs

   return "NO_NAME"; // no cursors supported ...
}

//___________________________________________________________________
TSQLResultSetMetaData* TSQLResultSet::GetMetaData()
{
   // Retrieves the number, types and properties of a 
   // TSQLResultSet's columns.
   //
   //  Returns:
   //       the description of a TSQLResultSet's columns
   //  Throws:
   //       TSQLException - if a database access error occurs

   return fMetaData ? fMetaData : fMetaData = new TSQLResultSetMetaData(this,fImp);
}

//___________________________________________________________________
Int_t TSQLResultSet::FindColumn( const TString& columnName )
{
   // Maps the given resultset column name to its TSQLResultSet
   // column index.
   //
   //  Parameters:
   //       columnName - the name of the column
   //  Returns:
   //       the column index
   //  Throws:
   //       TSQLException - if a database access error occurs
 
   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   
   for( int i=0; i < imp->fMYSQL_RES->field_count; i++ ) {
      !strcmp(columnName.Data(),imp->fMYSQL_RES->fields[i].name) ? return i :;;
   }
   return 0;
}

//___________________________________________________________________
Bool_t TSQLResultSet::IsBeforeFirst()
{
   // Indicates whether the cursor is before the first row in 
   // the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is before the first row, 
   //       kFALSE otherwise. Returns kFALSE when the
   //       result set contains no rows.
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   return (!imp->fMYSQL_RES->row_count) ? kFALSE : (fCurrentRow == -1);
}

//___________________________________________________________________
Bool_t TSQLResultSet::IsAfterLast()
{
   // Indicates whether the cursor is after the last row in 
   // the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is after the last row, 
   //       kFALSE otherwise. Returns kFALSE when the
   //       result set contains no rows.
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   return (!imp->fMYSQL_RES->row_count) ? kFALSE : (fCurrentRow == imp->fMYSQL_RES->row_count);
}
          
//___________________________________________________________________
Bool_t TSQLResultSet::IsFirst() 
{
   // Indicates whether the cursor is on the first row of 
   // the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is on the first row, 
   //       kFALSE otherwise.
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   return (!imp->fMYSQL_RES->row_count) ? kFALSE : (fCurrentRow == 0);
}

//___________________________________________________________________
Bool_t TSQLResultSet::IsLast()
{
   // Indicates whether the cursor is on the last row of the 
   // result set.
   //
   //  Note: Calling the method IsLast() may be expensive because 
   //       the driver might need to fetch ahead one row in 
   //       order to determine whether the current row is the 
   //       last row in the result set.
   //
   //  Returns:
   //       kTRUE if the cursor is on the last row, 
   //       kFALSE otherwise.
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   return (!imp->fMYSQL_RES->row_count) ? kFALSE : (fCurrentRow == imp->fMYSQL_RES->row_count-1);
}

//___________________________________________________________________
void TSQLResultSet::BeforeFirst()
{
   // Moves the cursor to the front of the result set, just before 
   // the first row. Has no effect if the result set contains no 
   // rows.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY
 
   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if( imp->fOnInsertRow ) imp->fOnInsertRow = kFALSE;
   if( imp->fDoingUpdates )  imp->fDoingUpdates = kFALSE;
   
   if( !imp->fMYSQL_RES->row_count ) return;
   else {
      imp->fCurrentRow = -1;
            This_Row = null;
   } 
}

//___________________________________________________________________
void TSQLResultSet::AfterLast()
{
   // Moves the cursor to the end of the result set, just after 
   // the last row. Has no effect if the result set contains no 
   // rows.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if( imp->fOnInsertRow ) imp->fOnInsertRow = kFALSE;
   if( imp->fDoingUpdates ) imp->fDoingUpdates = kFALSE;
   
   if( !imp->fMYSQL_RES->row_count ) {
      imp->fRurrentRow = imp->fMYSQL_RES->row_count;
            This_Row = null;
   }
}

//___________________________________________________________________
Int_t TSQLResultSet::GetRow()
{
   // Retrieves the current row number. The first row is number 1, 
   // the second number 2, and so on.
   //
   //  Returns:
   //       the current row number; 0 if there is no current row
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   return ( imp->fCurrentRow < 0 || 
            imp->fCurrentRow > imp->fMYSQL_RES->row_count ) ? 0 : imp->fCurrentRow+1;
}

//___________________________________________________________________
//void TSQLResultSet::SetFetchDirection(Int_t direction)
//{
   // Gives a hint as to the direction in which the rows in this
   // result set will be processed. The initial value is determined
   // by the TSQLStatement that produced the result set.
   // The fetch direction may be changed at any time.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY and the fetch 
   //       direction is not forward
//
//}

//___________________________________________________________________
//Int_t TSQLResultSet::GetFetchDirection()
//{
   // Returns the fetch direction for this result set.
   //
   //  Returns:
   //       the current fetch direction for this result set
   //  Throws:
   //       TSQLException - if a database access error occurs
//
//   using namespace odbc;   
//   odbc::ResultSet* rs = (odbc::ResultSet*)fImp;
//      return_value = rs->getFetchDirection();
//}

//___________________________________________________________________
void TSQLResultSet::SetFetchSize(Int_t rows)
{
   // Gives the driver a hint as to the number of rows that
   // should be fetched from the database when more rows are needed 
   // for this result set. If the fetch size specified is zero, 
   // the driver ignores the value and is free to make its own
   // best guess as to what the fetch size should be. The default 
   // value is set by the statement that created the result set. 
   // The fetch size may be changed at any time.
   //
   //  Parameters:
   //       rows - the number of rows to fetch
   //  Throws:
   //       TSQLException - if a database access error occurs or the
   //       condition 0 <= rows <= GetMaxRows() is not satisfied.
   
      if (rows < 0 /* || rows > getMaxRows()*/) {
            throw new SQLException("Value must be between 0 and getMaxRows()", "S1009");
        }

        _fetch_size = rows;
}

//___________________________________________________________________
Int_t TSQLResultSet::GetFetchSize()
{
   // Returns the fetch size for this result set.
   //
   //  Returns:
   //       the current fetch size for this result set
   //  Throws:
   //       TSQLException - if a database access error occurs

   Int_t return_value = 0;
 
   return return_value;
}

//___________________________________________________________________
Int_t TSQLResultSet::GetType()
{
   // Returns the type of this result set. The type is
   // determined by the TSQLStatement that created the result set.
   //
   //  Returns:
   //       kTYPE_FORWARD_ONLY, kTYPE_SCROLL_INSENSITIVE, or
   //       kTYPE_SCROLL_SENSITIVE
   //  Throws:
   //       TSQLException - if a database access error occurs

   Int_t return_value = kTYPE_SCROLL_INSENSITIVE;
   return return_value;
}

//___________________________________________________________________
Int_t TSQLResultSet::GetConcurrency()
{
   // Returns the concurrency mode of this result set. The
   // concurrency used is determined by the TSQLStatement that 
   // created the result set.
   //
   //  Returns:
   //       the concurrency type, kCONCUR_READ_ONLY or 
   //                             kCONCUR_UPDATABLE
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   Int_t return_value = 0;

   return return_value;
}

//___________________________________________________________________
Bool_t TSQLResultSet::RowUpdated()
{
   // Indicates whether the current row has been updated. The
   // value returned depends on whether or not the result set 
   // can detect updates.
   //
   //  Returns:
   //       kTRUE if the row has been visibly updated by 
   //       the owner or another, and updates are detected
   //  Throws:
   //       TSQLException - if a database access error occurs
   //  See Also: 
   //       TSQLDatabaseMetaData::updatesAreDetected(Int_t)

   Bool_t return_value = kFALSE;

   return return_value;
}

//___________________________________________________________________
Bool_t TSQLResultSet::RowInserted()
{
   // Indicates whether the current row has had an insertion.
   //  The value returned depends on whether or not the 
   // result set can detect visible inserts.
   //
   //  Returns:
   //       kTRUE if a row has had an insertion and insertions 
   //       are detected
   //  Throws:
   //       TSQLException - if a database access error occurs
   //  See Also: 
   //       TSQLDatabaseMetaData::insertsAreDetected(Int_t)

   Bool_t return_value = kFALSE;

   return return_value;
}

//___________________________________________________________________
Bool_t TSQLResultSet::RowDeleted()
{
   // Indicates whether a row has been deleted. A deleted row
   // may leave a visible "hole" in a result set. This method 
   // can be used to detect holes in a result set. The value 
   // returned depends on whether or not the result set can 
   // detect deletions.
   //
   //  Returns:
   //       kTRUE if a row was deleted and deletions are detected
   //  Throws:
   //       TSQLException - if a database access error occurs
   //  See Also: 
   //       TSQLDatabaseMetaData::deletesAreDetected(Int_t)

   Bool_t return_value = kFALSE;
 
   return return_value;
}

//___________________________________________________________________
void TSQLResultSet::UpdateNull( Int_t columnIndex )
{
   // Give a nullable column a null value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   //
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateBoolean( Int_t columnIndex,Bool_t x )
{
   // Updates a column with a boolean value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateByte( Int_t columnIndex,Char_t x )
{
   // Updates a column with a Char_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateShort( Int_t columnIndex,Short_t x )
{
   // Updates a column with a Short_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateInt( Int_t columnIndex,Int_t x )
{
   // Updates a column with an integer value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
 
}

//___________________________________________________________________
void TSQLResultSet::UpdateLong( Int_t columnIndex,Long_t x )
{
   // Updates a column with a Long_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
}

//___________________________________________________________________
void TSQLResultSet::UpdateFloat( Int_t columnIndex,Float_t x )
{
   // Updates a column with a Float_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
}

//___________________________________________________________________
void TSQLResultSet::UpdateDouble( Int_t columnIndex,
                                  Double_t x )
{
   // Updates a column with a Double value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateString( Int_t columnIndex,
                                  const TString& x )
{
   // Updates a column with a TString value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateBytes( Int_t columnIndex,
                                 const TArrayC& x )
{
   // Updates a column with a Char_t array value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
 
}

//___________________________________________________________________
void TSQLResultSet::UpdateDate( Int_t columnIndex,
                                const TSQLDate& x )
{
   // Updates a column with a TSQLDate value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateTime( Int_t columnIndex,
                                const TSQLTime& x )
{
   // Updates a column with a TSQLTime value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
 
}

//___________________________________________________________________
void TSQLResultSet::UpdateTimestamp( Int_t columnIndex,
                                     const TSQLTimestamp& x )
{
   // Updates a column with a TSQLTimestamp value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
 
}

//___________________________________________________________________
void TSQLResultSet::UpdateAsciiStream( Int_t columnIndex,
                                       TBuffer* x,
                                       Int_t length )
{
   // Updates a column with an ascii stream value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs  

}

//___________________________________________________________________
void TSQLResultSet::UpdateBinaryStream( Int_t columnIndex,
                                        TBuffer* x,
                                        Int_t length )
{
   // Updates a column with a binary stream value. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream   
   //  Throws:
   //       TSQLException - if a database access error occurs

}

//___________________________________________________________________
void TSQLResultSet::UpdateObject( Int_t columnIndex,TObject* x )
{
   // Updates a column with a ROOT object. The UpdateXXX
   // methods are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream   
   //  Throws:
   //       TSQLException - if a database access error occurs
 
   TBuffer *b = new TBuffer(TBuffer::kWrite);
   b->WriteObject(x);
   UpdateBinaryStream(columnIndex,b,b->BufferSize());
   b->DetachBuffer();
   delete b; 
}

//___________________________________________________________________
void TSQLResultSet::UpdateNull( const TString& columnName )
{
   // Updates a column with a null value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateNull(FindColumn(columnName));
}

//___________________________________________________________________
void TSQLResultSet::UpdateBoolean( const TString& columnName,Bool_t x )
{
   // Updates a column with a boolean value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateBoolean(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateByte( const TString& columnName,Char_t x )
{
   // Updates a column with a Char_t value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateByte(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateShort( const TString& columnName,Short_t x )
{
   // Updates a column with a short value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateShort(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateInt( const TString& columnName,Int_t x )
{
   // Updates a column with an integer value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateInt(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateLong( const TString& columnName,Long_t x )
{
   // Updates a column with a long value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateLong(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateFloat( const TString& columnName,Float_t x )
{
   // Updates a column with a float value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 

   UpdateFloat(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateDouble( const TString& columnName,Double_t x )
{
   // Updates a column with a double value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateDouble(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateString( const TString& columnName,
                                  const TString& x )
{
   // Updates a column with a TString value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateString(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateBytes( const TString& columnName,
                                 const TArrayC& x )
{
   // Updates a column with a bytes array value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 

   UpdateBytes(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateDate( const TString& columnName,
                                const TSQLDate& x )
{
   // Updates a column with a TSQLDate value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 

   UpdateDate(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateTime( const TString& columnName,
                                const TSQLTime& x )
{
   // Updates a column with a TSQLTime value. The UpdateXXX methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs 
   
   UpdateTime(FindColumn(columnName),x);
}

//___________________________________________________________________
void TSQLResultSet::UpdateTimestamp( const TString& columnName,
                                     const TSQLTimestamp& x )
{
   // Updates a column with a TSQLTimestamp value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   UpdateTimestamp(FindColumn(columnName),x);
}   

//___________________________________________________________________
void TSQLResultSet::UpdateAsciiStream( const TString& columnName,
                                       TBuffer* x,
                                       Int_t length )
{
   // Updates a column with an ascii stream value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs

   UpdateAsciiStream(FindColumn(columnName),x,length);
}

//___________________________________________________________________
void TSQLResultSet::UpdateBinaryStream( const TString& columnName,
                                        TBuffer* x,
                                        Int_t length )
{
   // Updates a column with a binary stream value. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   UpdateBinaryStream(FindColumn(columnName),x,length); 
}

//___________________________________________________________________
void TSQLResultSet::UpdateObject(const TString& columnName,TObject* x)
{
   // Updates a column with a ROOT object. The update methods
   // are used to update column values in the current row, 
   // or the insert row. The UpdateXXX methods do not update the
   // underlying database; instead the UpdateRow() or InsertRow() 
   // methods are called to update the database.
   // 
   //  Parameters:
   //       columnIndex - the first column is 1, the second is 2, ...
   //       x - the new column value
   //       length - length of stream
   //  Throws:
   //       TSQLException - if a database access error occurs
   
   UpdateObject(FindColumn(columnName),x); 
}

//___________________________________________________________________
void TSQLResultSet::InsertRow()
{
   // Inserts the contents of the insert row into the result set
   // and the database. Must be on the insert row when this method
   // is called.
   //
   //  Throws:
   //     TSQLException - if a database access error occurs, if 
   //     called when not on the insert row, or if not all of 
   //     non-nullable columns in the insert row have been given 
   //     a value.


}

//___________________________________________________________________
void TSQLResultSet::UpdateRow()
{
   // Updates the underlying database with the new contents of
   // the current row. Cannot be called when on the insert row.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or if
   //       called when on the insert row

}

//___________________________________________________________________
void TSQLResultSet::DeleteRow()
{
   // Deletes the current row from the result set and the underlying 
   // database. Cannot be called when on the insert row.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       if called when on the insert row.
 
}

//___________________________________________________________________
void TSQLResultSet::RefreshRow()
{
   // Refreshes the current row with its most recent value in
   // the database. Cannot be called when on the insert row. 
   // The RefreshRow() method provides a way for an application to
   // explicitly tell the driver to refetch a row(s) from the
   // database. An application may want to call RefreshRow() when 
   // caching or prefetching is being done by the driver to
   // fetch the latest value of a row from the database. The 
   // driver may actually refresh multiple rows at once if the 
   // fetch size is greater than one. All values are refetched
   // subject to the transaction isolation level and cursor 
   // sensitivity. If RefreshRow() is called after calling UpdateXXX,
   // but before calling UpdateRow(), then the updates made to the 
   // row are lost. Calling the method RefreshRow() frequently will 
   // likely slow performance.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       if called when on the insert row
   

}

//___________________________________________________________________
void TSQLResultSet::CancelRowUpdates()
{
   // Cancels the updates made to a row. This method may be
   // called after calling an UpdateXXX method(s) and before 
   // calling UpdateRow() to rollback the updates made to a row. 
   // If no updates have been made or UpdateRow() has already been 
   // called then this method has no effect.
   //
   //   Throws:
   //        TSQLException - if a database access error occurs or if 
   //         called when on the insert row

}

//___________________________________________________________________
void TSQLResultSet::MoveToInsertRow()
{
   //  Moves the cursor to the insert row. The current cursor
   //  position is remembered while the cursor is positioned on 
   //  the insert row. The insert row is a special row associated 
   //  with an updatable result set. It is essentially a buffer 
   //  where a new row may be constructed by calling the UpdateXXX 
   //  methods prior to inserting the row into the result set. 
   //  Only the UpdateXXX, GetXXX, and InsertRow() methods may be 
   //  called when the cursor is on the insert row.
   //  All of the columns in a result set must be given a value 
   //  each time this method is called before calling InsertRow(). 
   //  The method UpdateXXX must be called before a GetXXX method 
   //  can be called on a column value.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs 
   //       or the result set is not updatable
 
}

//___________________________________________________________________
void TSQLResultSet::MoveToCurrentRow()
{
   // Moves the cursor to the remembered cursor position,
   // usually the current row. This method has no effect if the 
   // cursor is not on the insert row.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set is not updatable
   

}

//___________________________________________________________________
TSQLStatement* TSQLResultSet::GetStatement() const
{
   // Returns the TSQLStatement that produced this TSQLResultSet 
   // object. If the result set was generated some other way, such 
   // as by a TSQLDatabaseMetaData method,this method returns null.
   //
   //  Returns:
   //       the TSQLStatment that produced the result set or null 
   //       if the result set was produced some other way
   //  Throws:
   //       TSQLException - if a database access error occurs

   return fStatement;
}

//___________________________________________________________________
TSQLRow* TSQLResultSet::Next()
{
   // Moves the cursor down one row from its current position. A
   // TSQLResultSet cursor is initially positioned before the first 
   // row; the first call to next makes the first row the current 
   // row; the second call makes the second row the current row, 
   // and so on.
   // 
   // If an input stream is open for the current row, a call to the
   // method next will implicitly close it. The TSQLResultSet's 
   // warning chain is cleared when a new row is read.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE) if the new current row is valid; 
   //       null(kFALSE) if there are no more rows
   //  Throws:
   //       TSQLException - if a database access error occurs

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if( imp->fOnInsertRow ) imp->fOnInsertRow = kFALSE;
   if( imp->fDoingUpdates )  imp->fDoingUpdates = kFALSE;
   
   if( !imp->fMYSQL_RES->row_count ) return; 
 
   return return_value ? fRow->Set(this) : 0;
}

//___________________________________________________________________
TSQLRow* TSQLResultSet::First()
{
   // Moves the cursor to the first row in the result set.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a valid row; 
   //       null(kFALSE) if there are no rows in the result set
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   MySQLStatementPrivate* stmt = (MySQLStatementPrivate*)fStatement->fImp;
   MySQLConnectionPrivate* con = (MySQLConnectionPrivate*)fStatement->fConnection->fImp;

   if( imp->fCurrentRow || imp->fCursorType != kTYPE_FORWARD_ONLY ) {
      Throw();
      return 0;
   }

   if( imp->fOnInsertRow ) imp->fOnInsertRow = kFALSE;
   
   if( !imp->fMYSQL_RES->row_count || con->fMYSQL->status==MYSQL_STATUS_USE_RESULT ) return 0;
   else { 
      if( imp->fDoingUpdates )  imp->fDoingUpdates = kFALSE;
      imp->fCurrentRow = 0;
      mysql_data_seek(imp->fMYSQL_RES,0L);

      return fRow->Set(imp->fMYSQL_RES);
   } 
}

//___________________________________________________________________
TSQLRow* TSQLResultSet::Absolute( Int_t row )
{
   // Moves the cursor to the given row number in the result set. 
   // If the row number is positive, the cursor moves to the 
   // given row number with respect to the beginning of the 
   // result set. The first row is row 1, the second is row 2, 
   // and so on. 
   //
   //  If the given row number is negative, the cursor moves to an
   // absolute row position with respect to the end of the result 
   // set. For example, calling Absolute(-1) positions the cursor
   // on the last row, Absolute(-2) indicates the next-to-last row, 
   // and so on. 
   //
   //  An attempt to position the cursor beyond the first/last row 
   // in the result set leaves the cursor before/after the first/last
   // row, respectively. 
   //
   //  Note: calling Absolute(1) is the same as calling First(). 
   //        calling Absolute(-1) is the same as calling Last().
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on the result set; 
   //       null(kFALSE) otherwise
   //  Throws:
   //       TSQLException - if a database access error occurs or
   //       row is 0, or result set type is kTYPE_FORWARD_ONLY

    if (row == 0) {
            throw new SQLException("Cannot absolute position to row 0", "S1009");
        }

        if (_on_insert_row) {
            _on_insert_row = false;
        }

        if (_doing_updates) {
            _doing_updates = false;
        }

        if (row == 1) {
            return first();
        }
        else if (row == -1) {
            return last();
        }

        if (row > Rows.size()) {
            afterLast();
            
            return false;
        }
        else if (row < 0) {

            // adjust to reflect after end of result set
            int new_row_position = Rows.size() + row + 1;
            
            if (new_row_position <= 0) {
                beforeFirst();
                
                return false;
            }
            else {
                return absolute(new_row_position);
            }
        }
        else {
            row--; // adjust for index difference
            currentRow = row;
            This_Row = (byte[][])Rows.elementAt(currentRow);

            return true;
        } 
}

//___________________________________________________________________
TSQLRow* TSQLResultSet::Relative(Int_t rows)
{
   // Moves the cursor a relative number of rows, either positive or
   // negative. Attempting to move beyond the first/last row in 
   // the result set positions the cursor before/after the the
   // first/last row. Calling Relative(0) is valid, but does not 
   // change the cursor position. 
   //
   //  Note: Calling Relative(1) is different from calling Next() 
   //       because is makes sense to call Next() when there is 
   //       no current row, for example, when the cursor is 
   //       positioned before the first row or after the last row
   //       of the result set.
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a row; 
   //       null(kFALSE) otherwise
   //  Throws:
   //       TSQLException - if a database access error occurs, 
   //       there is no current row, or the result set type 
   //       is kTYPE_FORWARD_ONLY

   int new_row_position = currentRow + rows + 1;
}

//___________________________________________________________________
TSQLRow* TSQLResultSet::Previous()
{
   // Moves the cursor to the previous row in the result set. 
   //
   //  Note: Previous() is not the same as Relative(-1)
   //       because it makes sense to call Previous()
   //       when there is no current row.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a valid row; 
   //       null(kFALSE) if it is off the result set
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY

   Bool_t return_value = kFALSE;
 
   return return_value  ? fRow->Set(this) : 0;   
}

//___________________________________________________________________
TSQLRow* TSQLResultSet::Last()
{
   // Moves the cursor to the last row in the result set.
   //
   //  Returns:
   //       pointer to TSQLRow(kTRUE)  if the cursor is on a valid row; 
   //       null(kFALSE) if there are norows in the result set
   //
   //  Throws:
   //       TSQLException - if a database access error occurs or 
   //       the result set type is kTYPE_FORWARD_ONLY

   Bool_t return_value = kFALSE;
   return return_value  ? fRow->Set(this) : 0;
}

//___________________________________________________________________
Int_t TSQLResultSet::GetFieldCount()
{
   // Get number of fields(aka columns) in result.

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;
   return imp->fMYSQL_RES->field_count;
}

//___________________________________________________________________
const char* TSQLResultSet::GetFieldName(Int_t field)
{
   // Get name of specified field( aka column ).

   MySQLResultSetPrivate* imp = (MySQLResultSetPrivate*)fImp;

   if( (column > imp->fMYSQL_RES->field_count) || (column < 1) ) {
      return (set_stmt_error(stmt,"S1002","Invalid column number",0));
      return "";
   }

   return imp->MYSQL_RES->fields[column-1].name;
}

//___________________________________________________________________
void TSQLResultSet::Close(Option_t *option)
{
   // Releases this TSQLResultSet object's database and resources
   // immediately instead of waiting for this to happen when it is 
   // automatically closed. 
   //
   // Note: A TSQLResultSet is automatically closed by the 
   // statement that generated it when that statement 
   // is closed, re-executed, or is used to retrieve the next
   // result from a sequence of multiple results. A TSQLResultSet 
   // is also automatically closed when it is garbage collected.
   //
   //  Throws:
   //       TSQLException - if a database access error occurs
 
   
   fMetaData = 0;   
   fRow = 0;
   fImp = 0;
   Destroyed();
}

//////////////////////// Print utility //////////////////////////////
//___________________________________________________________________
Int_t GetValueFromOption(const TString& pattern,const TString& option)
{
   // internal use func.

   Ssiz_t t1,t2;    
   const char* tmp;

   TString stropt = option; 
   stropt.ReplaceAll(" ",""); // strip blanks
   stropt.ToLower();

   t1 = stropt.Index(pattern.Data());
   t1 = t2 = stropt.Index("=",t1) + 1;
   TString str = stropt(t1,1024); // 
   tmp = str.Data();
 
   for(int i=0;isdigit(tmp[i])!=0;i++) t2=i+1;
   str = stropt(t1,t2);
   return atoi(str.Data()); 
}

//___________________________________________________________________
void TSQLResultSet::Print(Option_t *option)
{
   // Print a resultset contents
   //
   // The following options are valid:
   //
   //    begin=nnn - start print from #nnn'th row, for example Print("begin=100")
   //    end=nnn   - end print at  #nnn'th row, for example Print("begin=100 end=1000")
   //    nrows=nnn - print #nnn rows, for example Print("begin=100 nrows=1000")

   if(!fImp) {
      Warning("Print()","TSQLResultSet is destroyed\n");
      Throw(new TSQLException("TSQLResultSet is destroyed"));
      Destroyed(); 
      return;
   }

   TString colname;
   Int_t ds;
   Int_t dl;
   Int_t* nn;
   Int_t* pd1;
   Int_t pd2;
   TString str;
   Int_t save_row = GetRow(); 
   Int_t cur_row;
   Int_t nr = 0;

   Int_t srow = save_row;  // start from srow, default is current 
   Int_t nrows = -1; // -1 - stand for "all rows" 
   Int_t erow = -1;  // -1 - stand for "to the last row" 

   TString stropt = option;
   stropt.ToLower();

   if(stropt.Contains("begin")) {
      srow = GetValueFromOption("begin",stropt);
   }

   if (stropt.Contains("end")) {
      erow = GetValueFromOption("end",stropt);
   } 

   if (stropt.Contains("nrows")) {
      nrows = GetValueFromOption("nrows",stropt);
   }

   Int_t ncols = fMetaData->GetColumnCount();

   nn  = new Int_t[ncols+1];
   pd1 = new Int_t[ncols+1];

   for(int i=1; i<ncols+1; i++) {
      colname = fMetaData->GetColumnName(i);
      ds = fMetaData->GetColumnDisplaySize(i)+2;
      dl = colname.Length() + 2;
      nn[i] = TMath::Max(dl,ds);
      pd1[i] = nn[i]-dl;
   }   

   //  
   for(int i=1; i<ncols+1; i++) {
      cout << "+"; cout.fill('-'); cout.width(nn[i]+1); cout << "+";
   }  cout << endl;

   for(int i=1; i<ncols+1; i++) { 
      colname = fMetaData->GetColumnName(i); 
      cout << "| " << colname << " "; 
      cout.fill(' '); cout.width(pd1[i]+1); cout << "|";
   } cout << endl;

   //  
   for(int i=1; i<ncols+1; i++) {
      cout << "+"; cout.fill('-'); cout.width(nn[i]+1); cout << "+";
   }  cout << endl;

   cur_row = GetRow();

   if(fStatement) {
      if(fStatement->GetResultSetType() != kTYPE_FORWARD_ONLY ) {
         Absolute(srow-1);
      } else {
         if(srow>cur_row) {
            while ( Next() && cur_row+2 < srow) cur_row = GetRow();
         }
      }
   }

   static TStopwatch timer;
   timer.Start(kTRUE);

   nr = 0;
   cur_row = GetRow();

   while ( Next() ) {
 
      if(nrows > 0 && nr >= nrows) break;      
      if(erow > 0 && cur_row >= erow ) break;
      nr++;
      cur_row = GetRow();

      for(int i=1; i<ncols+1; i++) {
         str = GetString(i);
         cout << "| " << str;
         pd2 = nn[i] - str.Length();
         cout.fill(' '); cout.width(pd2); cout << "|"; 
      }  cout << endl;
   }

   for(int i=1; i<ncols+1; i++) {
      cout << "+"; cout.fill('-'); cout.width(nn[i]+1); cout << "+";
   }  cout << endl;

   timer.Stop();
   Double_t rtime = timer.RealTime();
//   Double_t ctime = timer.CpuTime();
   cout << nr << " rows in set. ( Real time: " << rtime << " seconds )" << endl; 

   if(fStatement) { 
      if(fStatement->GetResultSetType() != kTYPE_FORWARD_ONLY ) {
         Absolute(save_row);
      } else {
         Warning("Print","To set cursor to initial position -> re-execute Query.");
      }
   }
   delete [] nn;
   delete [] pd1;
}

//___________________________________________________________________
TTree* TSQLResultSet::Tree(Int_t begin,Int_t end)
{
   // Writes resultset content to ROOT tree
   //
   // This method creates "new TTree". 
   // To avoid memory leakage it should be deleted if not used.
   //
   // See also TTree
   //
   // Comment: this method is experimental nad buggy
   
   TString leafList;    // leaf description string
   TString clmname;     // column name

   Int_t siz;
   Int_t ncollumns;
   char* buf;
   Int_t type,offset,prec;
   TString str;
   char tmpstr[40];

   Int_t  intg;
   Short_t shrt;
   Float_t flt;
   Double_t dbl;
   Int_t yy, mm, dd, hh, mi, ss;
   UInt_t t;
   struct tm tp;
   Int_t save_row = GetRow(); 
   Int_t cur_row;

   Int_t srow = begin > 0 ? begin : save_row; 
   Int_t erow = end > 0 ? end : -1;
   Int_t tmp;

   if(srow>erow) { 
      tmp = erow; 
      erow = srow;
      srow = tmp; 
   }

   // calculate "leaf buffer" size
   //   
   ncollumns = fMetaData->GetColumnCount();

   for( int i=1; i <= ncollumns; ++i ) {
      type = fMetaData->GetColumnType(i);
            
      switch( type ) { 
      case kCHAR: 
      case kVARCHAR:
        siz += fMetaData->GetPrecision(i)+1; // length + zero
        break;
      case kINTEGER:
         siz += sizeof(Int_t);
         break;
      case kDATE:
      case kTIME:
      case kTIMESTAMP:
         siz += sizeof(UInt_t);
         break;      
      case kBIT:       
      case kTINYINT:
      case kSMALLINT:
         siz += sizeof(Short_t);
         break;
      case kREAL:
         siz += sizeof(Float_t);
         break;
      case kLONGVARCHAR: // not resolved yet how to handle   
      case kLONGVARBINARY:
      case kVARBINARY:
         break;  
      case kBIGINT:     // convert all these types to Double_t
      case kDECIMAL:
      case kNUMERIC:
      case kDOUBLE:
      case kFLOAT:
      default:
         siz += sizeof(Double_t);
         break;      
      }  
   }

   // determine leaf description string
   //
   for( int i=1; i <= ncollumns; ++i ) {
      type = fMetaData->GetColumnType(i);
      clmname = fMetaData->GetColumnName(i);
      
      switch( type ) {
      case kCHAR: 
      case kVARCHAR:
         prec = fMetaData->GetPrecision(i)+1;
         sprintf(tmpstr,"[%d]",prec);
         leafList += clmname + tmpstr + "/C:"; // 
         break;
      case kINTEGER:
         leafList += clmname + "/I:"; // signed integer 
         break;
      case kDATE:
      case kTIME:
      case kTIMESTAMP:
         leafList += clmname + "/i:"; // unsigned integer ( time_t format )
         break;
      case kBIT:        
      case kTINYINT:      
      case kSMALLINT:
         leafList += clmname + "/S:"; //  signed short        
         break;
      case kREAL:
          leafList += clmname + "/F:"; // floating point
         break;
      case kLONGVARCHAR: // not resolved yet how to handle   
      case kLONGVARBINARY:
      case kVARBINARY: 
         break;         
      case kBIGINT:     // convert all these types to Double_t
      case kDECIMAL:
      case kNUMERIC:          
      case kDOUBLE:
      case kFLOAT:
      default:
         leafList += clmname + "/D:"; // double
         break;
      }
   }  
   if(!leafList.IsNull()) leafList.Resize(leafList.Length()-1);   // cut off last ":"

   //  Dinamically allocate  "leaf buffer"  
   //
   buf = new char[siz]; // buffer

   TString tblname =  fMetaData->GetTableName(1);

   if(tblname.IsNull()) { // if table name unknown => generate "random name" 
      tblname = "table"; 
      sprintf(tmpstr,"%d",gRandom->Integer(1000));
      tblname += tmpstr;
   }

   // Create a ROOT Tree
   //
   TTree* tree = new TTree(tblname.Data(),"Created by TSQLResultSet:Tree() method");
  
   tree->Branch(tblname.Data(),(void*)buf,leafList.Data());

   // skip to start 
   cur_row = GetRow();

   if(fStatement) { 
      if(fStatement->GetResultSetType() != kTYPE_FORWARD_ONLY ) {
         Absolute(srow-1);
      } else {
         if(srow>cur_row) {
            while ( Next() && cur_row+2 < srow) cur_row = GetRow();
         }
      }
   }
   // tree filling 
   //
   while( Next() ) {   // iterate rows
      offset = 0;
   
      if(erow>0 && cur_row >= erow) break;
      cur_row = GetRow();

      for( int i=1; i <= ncollumns; ++i ) {
         type = fMetaData->GetColumnType(i);
         
         switch( type ) {      
         case kCHAR:  
         case kVARCHAR:
            siz = fMetaData->GetPrecision(i)+1; 
            str = GetString(i);
            memcpy(&buf[offset],str.Data(),siz); 
            break;  
         case kINTEGER:
            siz = sizeof(Int_t);
            intg = GetInt(i);
            memcpy(&buf[offset],&intg,siz); 
            break;
         case kBIT:
         case kTINYINT:  
         case kSMALLINT:
            siz = sizeof(Short_t);
            shrt = GetShort(i);
            memcpy(&buf[offset],&shrt,siz); 
            break;
         case kREAL:
            siz = sizeof(Float_t);
            dbl = GetFloat(i);
            memcpy(&buf[offset],&flt,siz); 
            break;
         case kDATE: // convert all date-times into time_t
         case kTIME:       // probably not working for kTIME  
         case kTIMESTAMP: 
            siz = sizeof(UInt_t);
            str = GetString(i);
            sscanf(str.Data(), "%d-%d-%d %d:%d:%d", 
                                &yy, &mm, &dd, &hh, &mi, &ss);
            tp.tm_year  = yy-1900;
            tp.tm_mon   = mm;
            tp.tm_mday  = dd;
            tp.tm_hour  = hh;
            tp.tm_min   = mi;
            tp.tm_sec   = ss;
            tp.tm_isdst = -1;
            t = (UInt_t)mktime(&tp);
            memcpy(&buf[offset],&t,siz);
            break;            
         case kLONGVARCHAR: // not resolved  how to handle   
         case kLONGVARBINARY:
         case kVARBINARY:
            break;
         case kBIGINT:     // convert all these types to Double_t
         case kDECIMAL:
         case kNUMERIC:
         case kDOUBLE:
         case kFLOAT:                        
         default:
            siz = sizeof(Double_t);
            dbl = GetDouble(i);
            memcpy(&buf[offset],&dbl,siz); 
            break;      
         }  
         offset += siz;
      }
      tree->Fill();
   } 
   delete buf;

   if(fStatement) { 
      if(fStatement->GetResultSetType() != kTYPE_FORWARD_ONLY ) {
         Absolute(save_row);
      } else {
         Warning("Print","To set cursor to initial position -> re-execute Query.");
      }
   }
   return tree;  
}
