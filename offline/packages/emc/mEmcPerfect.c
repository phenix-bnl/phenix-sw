#include <assert.h>
#include "dio_trk.hh"
#include "mEmcPerfect.h"
#include "emlLib.h"

/** This module is used for "perfect tracking"; for each track that
    reaches the calorimeter it will store the impact point and the
    energy deposited by this track - irrespective of the fact whether
    an actual clustering would find this particle or not.
    Detailed Documentation:
    \URL{http://www.phenix.bnl.gov/WWW/emcal/documentation/offline/doc99}
    @author Gabor David \URL{mailto:david@bnl.gov}
    @version 1.0
*/
long mEmcPerfect_(
  TABLE_HEAD_ST     *dEmcGeaHit_h,     DEMCGEAHIT_ST       *dEmcGeaHit ,
  TABLE_HEAD_ST *dEmcClusterLocal_h, DEMCCLUSTERLOCAL_ST *dEmcClusterLocal ,
  TABLE_HEAD_ST *dEmcGeaClusterTrack_h, DEMCGEACLUSTERTRACK_ST *dEmcGeaClusterTrack )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mEmcPerfect_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mEmcPerfect.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:         dEmcGeaHit    - PLEASE FILL IN DESCRIPTION HERE
**:        dEmcGeaHit_h   - header Structure for dEmcGeaHit
**:    INOUT:
**:      OUT:
**:   dEmcClusterLocal    - PLEASE FILL IN DESCRIPTION HERE
**:  dEmcClusterLocal_h   - header Structure for dEmcClusterLocal
**:  dEmcGeaClusterTrack    - PLEASE FILL IN DESCRIPTION HERE
**:  dEmcGeaClusterTrack_h   - header Structure for dEmcGeaClusterTrack
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/


  long i,k;
  long istaf;

  int iarm;
    
 int error;
 int nfile;
 int status;
 int true_track;
 int idpart;
 float ptot,ptheta,pphi,r_vertex,z_vertex,theta_vertex,phi_vertex;
 int itparent,idparent;
 
 static int true_track_prev;

  /* Executable */

  if (dEmcGeaHit_h->nok <=0) return (STAFCV_BAD);
  
  istaf = 0;
  true_track_prev = 0;
  
    
  for (i = 0; i < dEmcGeaHit_h->nok; i++)
    {

      true_track = dEmcGeaHit[i].true_track;
      if(true_track_prev != true_track)
	{
	  true_track_prev = true_track;
	  
	  status = dio_ptrkstack(&true_track, &nfile,&error, 
                              &ptot, &ptheta, &pphi,
		              &r_vertex, &z_vertex, 
                              &theta_vertex, &phi_vertex,
                              &itparent, &idparent, &idpart);
	  assert(status == 0);

	  if(error == 0)
	    {
	      iarm = 0;
	      if (dEmcGeaHit[i].sector >= 5)
		{
		  iarm = 1;
		}
	      /*		  
	      true_track_array[4] = idpart;
	      */
	      dEmcClusterLocal[istaf].id = istaf + 1;
	      dEmcClusterLocal[istaf].runno = 1;
	      dEmcClusterLocal[istaf].evno = 1;
	      /*
	      dEmcClusterLocal[istaf].clusno = true_track_array[0];
	      */
	      dEmcClusterLocal[istaf].clusno = 0;
	      dEmcClusterLocal[istaf].method = 1;
	      dEmcClusterLocal[istaf].arm = iarm;

	      if(iarm == 0)
		{
		  dEmcClusterLocal[istaf].sector = dEmcGeaHit[i].sector - 1;
		}
	      else
		{
		  dEmcClusterLocal[istaf].sector = 8 - dEmcGeaHit[i].sector;
		}
	      
	      dEmcClusterLocal[istaf].runno = 1;
	      for(k=0; k<=2; k++)
		{
		  dEmcClusterLocal[istaf].xyz[k] = dEmcGeaHit[i].xyz[k];
		  dEmcClusterLocal[istaf].dxyz[k] = 0.0;
		}
	      dEmcClusterLocal[istaf].e = ptot;
	      dEmcClusterLocal[istaf].de = 0.0;
	      dEmcClusterLocal[istaf].tof = dEmcGeaHit[i].tof;
	      dEmcClusterLocal[istaf].dtof = 0.0;
	      dEmcClusterLocal[istaf].qual = 0.0;
	      dEmcClusterLocal[istaf].pid = dEmcGeaHit[i].partid;
	      dEmcClusterLocal[istaf].prob_photon = 0.0;
	      dEmcClusterLocal[istaf].prob_neuhad = 0.0;
		  
		  
	      dEmcGeaClusterTrack[istaf].id = istaf + 1;
	      dEmcGeaClusterTrack[istaf].clusid = istaf;
	      dEmcGeaClusterTrack[istaf].input = 0;

	      for ( k = 0; k < 3; k++)
		{
		  dEmcGeaClusterTrack[istaf].trkno[k] = 0;
		  dEmcGeaClusterTrack[istaf].pid[k] = 0;
		  dEmcGeaClusterTrack[istaf].ptot[k] = 0;
		  dEmcGeaClusterTrack[istaf].xyz[k][0] = 0;
		  dEmcGeaClusterTrack[istaf].xyz[k][1] = 0;
		  dEmcGeaClusterTrack[istaf].xyz[k][2] = 0.0;
		  dEmcGeaClusterTrack[istaf].edep[k] = 0.0;
		  dEmcGeaClusterTrack[istaf].efrac[k] = 0.0;
		  dEmcGeaClusterTrack[istaf].measxyz[k] = 0.0;
		}
	      
	      dEmcGeaClusterTrack[istaf].trkno[0] = true_track;
	      dEmcGeaClusterTrack[istaf].pid[0] = dEmcClusterLocal[istaf].pid;
	      dEmcGeaClusterTrack[istaf].edep[0] = dEmcClusterLocal[istaf].e;
	      dEmcGeaClusterTrack[istaf].mease = dEmcClusterLocal[istaf].e;
	      for(k=0; k<=2; k++)
		{
		  dEmcGeaClusterTrack[istaf].xyz[0][k] = 
		    dEmcClusterLocal[istaf].xyz[k];
		  dEmcGeaClusterTrack[istaf].measxyz[k] = 
		    dEmcClusterLocal[istaf].xyz[k];
		}

	      istaf = istaf + 1;
	    }
	  
	}	/* End of case when there is a new track */
      
    }		/* End of loop over i, all hits */
  
  dEmcClusterLocal_h->nok = istaf;
  dEmcGeaClusterTrack_h->nok = istaf;
	    

   return STAFCV_OK;
}
