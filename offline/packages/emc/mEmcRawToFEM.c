#include "mEmcRawToFEM.h"
#include "emlLib.h"

#include <stdio.h>

/** This module converts the "raw" output data of the simulation response 
    chain artificially into data in the FEM format, using a special,
    simulation-specific map.  This is a step needed to bring simulated
    data into the same PRDF format as the real data, so that the
    reconstruction chain would not know whether it works on simulated
    or real data.
    Detailed Documentation:
    \URL{http://www.phenix.bnl.gov/WWW/emcal/documentation/offline/doc99}
    @author Gabor David \URL{mailto:david@bnl.gov}
    @version 1.0
*/
long mEmcRawToFEM_(
  TABLE_HEAD_ST    *dEmcRawData_h,    DEMCRAWDATA_ST      *dEmcRawData ,
  TABLE_HEAD_ST    *dEmcFEMData_h,    DEMCFEMDATA_ST      *dEmcFEMData )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mEmcRawToFEM_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mEmcRawToFEM.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:        dEmcRawData    - PLEASE FILL IN DESCRIPTION HERE
**:       dEmcRawData_h   - header Structure for dEmcRawData
**:    INOUT:
**:      OUT:
**:        dEmcFEMData    - PLEASE FILL IN DESCRIPTION HERE
**:       dEmcFEMData_h   - header Structure for dEmcFEMData
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/

  short i,j;
  long rawdata[5][4608][4][2];   /* Max value for PbGl, PbSc is 2592 only */
  long activemodule[32][4][2];   /* One for each FEM module */
  int ll;
  long iarm,isector,iz,iy,itower,imod,ichan,imody,imodz,ichany,ichanz;
  long swkey;
  long FEMmodule;
  
  static unsigned short header = 0xFFFF;
  static short trailer = 0x0000;
  
  short timecell = 1;
  short precell = 2;
  short postcell = 3;
  short iflag,ievno,iclock,idetid;
  short ioffset;
  
  short i_FEMData;   /* Counter of output rows */

  long userword[8];
  

  /* ----------  Executable  -------------------------------*/

  if(dEmcRawData_h->nok <= 0)
    {
      printf("Error in mEmcRawToFEM: raw data table empty \n");
      return ( STAFCV_BAD);
    }
  /*
    Read raw data.  Using hwkey restore sector and serial number
    of channel within the sector.  Compute FEM module number that goes
    with the channel.  Indicate in a table that this FEM has at least
    one hit, and store raw data until read-in is finished
    We assume that one specific channel has only one raw data entry
    in dEmcRawData table
  */    

  for (ll = 0; ll < sizeof(rawdata)/sizeof(rawdata[0][0][0][0]); ll++)
    {
      *((long *)rawdata + ll) = 0;
    }
  for (ll = 0; ll < sizeof(activemodule)/sizeof(activemodule[0][0][0]); ll++)
    {
      *((long *)activemodule + ll) = 0;
    }
  for (ll = 0; ll < sizeof(userword)/sizeof(userword[0]); ll++)
    {
      *(userword + ll) = 0;
    }
  /* Take care of proper filling later ! */
  
  /* Set userwords to 5a00,  Now. 30, 1999 G. David */
  for (i=0;i<8;i++) userword[i] = 0x00005a00;
  


  ievno = dEmcRawData[0].evno & 0xFFFF;   /* Word only, not longword */
  iclock = ievno - 1;                     /* Dummy, take care of it ! */
  iflag = 0x0001;                         /* Dummy for now */
  /* idetid = 0x0080; -- flagged by scan-build as dead assignment */                        /* Dummy for now */
  idetid = 0x0004;
  
  i_FEMData = 0;
  
  
  for ( i = 0; i < dEmcRawData_h->nok ; i++)
    {
      /* Replace this section: derive everything from swkey,
	 to get more transparent to "Indexer"
	 Jan. 3, 2000, G. David */

      swkey = dEmcRawData[i].swkey;
      iarm = swkey / 100000; swkey = swkey - 100000 * iarm;
      isector = swkey / 10000; swkey = swkey - 10000 * isector;
      iy = swkey / 100; 
      iz = swkey - 100 * iy;

      /* Get supermodule and channel within supermodule */
      if(iarm == 0 || isector > 1)
	/* This is PbSc */
	{
	  /* Supermodule numbering goes like 6 * y + z */
	  imody = iy / 12;
	  imodz = iz / 12;
	  imod = 6 * imody + imodz;
	  /* Channel within supermodule goes like 12 * y + z */
	  ichany = iy % 12;
	  ichanz = iz % 12;
	  ichan = 12 * ichany + ichanz;
	  itower = 144 * imod + ichan;
	}
      else      
	/* This is PbGl */
	{
	  /* Super-duper-module numbering goes like 8 * y + z */
	  imody = iy / 12;
	  imodz = iz / 12;
	  imod = 8 * imody + imodz;
	  /* Channel within supermodule goes like 12 * y + z */
	  ichany = iy % 12;
	  ichanz = iz % 12;
	  ichan = 12 * ichany + ichanz;
	  itower = 144 * imod + ichan;
	}
      activemodule[imod][isector][iarm] = 1;
      
      /* 
	 In dEmcRawData all but the last 12 bits (11-0) are masked out 
	 repeat this for safety...
	 Now you can add high gain flag to bit 15
      */

      rawdata[0][itower][isector][iarm] = dEmcRawData[i].tdc & 0x00000FFF;
      rawdata[1][itower][isector][iarm] = 
	(dEmcRawData[i].adchipost & 0x00000FFF) + 0x00008000;
      rawdata[2][itower][isector][iarm] = dEmcRawData[i].adclopost & 0x00000FFF;
      rawdata[3][itower][isector][iarm] = 
	(dEmcRawData[i].adchipre & 0x00000FFF) + 0x00008000;
      rawdata[4][itower][isector][iarm] = dEmcRawData[i].adclopre & 0x00000FFF;
      
    }   /* End for i = 0, loop over RawData rows */

  /*
    OK, now let's write out one dEmcFEMData structure for each FEM
    that has at least one non-zero channel
   */

  for ( isector = 0; isector < 4; isector++)
    {
      for (iarm = 0; iarm < 2; iarm++)
	{
	  for ( imod = 0; imod < 32; imod++)
	    {
	      if( activemodule[imod][isector][iarm] > 0 )
		{
		  dEmcFEMData[i_FEMData].header = header;
		  dEmcFEMData[i_FEMData].detid = idetid;
		  dEmcFEMData[i_FEMData].evno = ievno;
		  /* 
		     Eventually check how module is encoded!
		     Right now it is similar to "hwkey"
		  */
		  /*
		    dEmcFEMData[i_FEMData].module = isector * 0x2000 + imod;
		  */
		  /* Encode serially */
		  if(iarm == 0)
		    {
		      FEMmodule = 18 * isector + imod;
		    }
		  else
		    {
		      if(isector > 1)
			{
			  FEMmodule = 72 + 18 * (isector - 2) + imod;
			}
		      else
			{
			  FEMmodule = 108 + 32 * isector + imod;
			}
		    }
		  dEmcFEMData[i_FEMData].module = FEMmodule;

		  
		  dEmcFEMData[i_FEMData].flag = iflag;
		  dEmcFEMData[i_FEMData].clock = iclock;
		  dEmcFEMData[i_FEMData].timecell = timecell;
		  dEmcFEMData[i_FEMData].precell = precell;
		  dEmcFEMData[i_FEMData].postcell = postcell;
		  ioffset = imod * 144;
		  i = 0;
		  
		  for( itower = ioffset; itower < ioffset + 144; itower++)
		    {
		      for ( j = 0; j < 5; j++)
			{
			  dEmcFEMData[i_FEMData].data[i] =
			    rawdata[j][itower][isector][iarm] & 0x0000FFFF;
			  i = i + 1;
			  
			  if( i > 720)
			    {
			      printf("Error in mEmcRawToFEM: index overflow \n");
			    }
			}
		      
		    }  /* End loop over itower from ioffset to ioffset + 144 */
		  
		  for ( i = 0; i < 8; i++)
		    {
		      dEmcFEMData[i_FEMData].userword[i] = 
			userword[i] & 0x0000FFFF;
		    }
		  dEmcFEMData[i_FEMData].longparity = 0;
		  dEmcFEMData[i_FEMData].trailer = trailer;
		  
		  /* Increment table row count */
		  
		  i_FEMData = i_FEMData + 1;
		}  /* End if activemodule[imod][isector] > 0 */
	      
	    }   /* End loop over imod, max. number of FEM modules in sector */
	}    /* End loop over iarm */
      
    }    /* End loop over isector, all sectors */
  
  dEmcFEMData_h->nok = i_FEMData;
  

  return STAFCV_OK;
}
