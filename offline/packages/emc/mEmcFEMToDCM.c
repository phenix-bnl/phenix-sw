/*:>--------------------------------------------------------------------
**: compile with cc
**: FILE:       mEmcFEMToDCM.c.template
**: HISTORY:
**:             00jan93-v000a-hpl- Created by stic Version
**:  Id: idl.y,v 1.3 1998/04/20 19:56:35 leitch Exp  
**:<------------------------------------------------------------------*/
#include "mEmcFEMToDCM.h"
#include "emlLib.h"
#include <packetConstants.h>

#include <stdio.h>

long mEmcFEMToDCM_(
  TABLE_HEAD_ST    *dEmcFEMData_h,    DEMCFEMDATA_ST      *dEmcFEMData ,
  TABLE_HEAD_ST    *dEmcDCMData_h,    DEMCDCMDATA_ST      *dEmcDCMData )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mEmcFEMToDCM_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mEmcFEMToDCM.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:        dEmcFEMData    - PLEASE FILL IN DESCRIPTION HERE
**:       dEmcFEMData_h   - header Structure for dEmcFEMData
**:    INOUT:
**:      OUT:
**:        dEmcDCMData    - PLEASE FILL IN DESCRIPTION HERE
**:       dEmcDCMData_h   - header Structure for dEmcDCMData
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/

  short i_DCMData;
  unsigned long iflag,imodule,ievno,iclock,idetid;
  unsigned long iparity = 0;
  unsigned long itrailer = 255;
  unsigned long itimecell,iprecell,ipostcell;
  
  
  short i,j;
  long ichan;
  short icount;
  long itime,ihigain,ilogain;
  long ipre,ipost;

#define i_minvalue 100
  
  if(dEmcFEMData_h->nok <= 0)
    {
      printf("Error in mEmcFEMToDCM: FEM data table empty \n");
      return ( STAFCV_BAD);
    }

  /* 
     Right now one FEM row goes to one DCM row.
     Set up an additional counter, anticipating that more than one
     FEM may end up in the same DCM
  */
  i_DCMData = 0;

  
  for ( i = 0; i < dEmcFEMData_h->nok; i++)
    {
      iflag = 
	(dEmcFEMData[i].flag & 0x0000FFFF) + 0x000F0000; /* Bits 19-16 = 15 */

      imodule = 
	(dEmcFEMData[i].module & 0x0000FFFF) + 0x00060000; /* Bits 19-16 = 6 */
      ievno = 
	(dEmcFEMData[i].evno & 0x0000FFFF) + 0x00060000; /* Bits 19-16 = 6 */
      iclock = 
	(dEmcFEMData[i].clock & 0x0000FFFF) + 0x00060000; /* Bits 19-16 = 6 */
      idetid = 
	(dEmcFEMData[i].detid & 0x0000FFFF) + 0x00060000; /* Bits 19-16 = 6 */
      
      itimecell = 
	(dEmcFEMData[i].timecell & 0x0000FFFF) + 0x00020000; /* Bits 19-16 = 2 */
      iprecell = 
	(dEmcFEMData[i].precell & 0x0000FFFF) + 0x00040000; /* Bits 19-16 = 4 */
      ipostcell = 
	(dEmcFEMData[i].postcell & 0x0000FFFF) + 0x00010000; /* Bits 19-16 = 1 */

      /* icount = 0; -- flagged by scan-build as dead assignment */

      /* Add new header */

      /*      dEmcDCMData[i_DCMData].nWords = 453;  Hardwired: pass-through */
      dEmcDCMData[i_DCMData].nWords = 450; /* Hardwired: pass-through */
      /*      dEmcDCMData[i_DCMData].scheme = 0;  Hardwired: pass-through */
      dEmcDCMData[i_DCMData].scheme = IDPBSC_DCM0;

      /*      dEmcDCMData[i_DCMData].packetID = 0x80000000 + i_DCMData; */
      /* Packet ID form changed after Sep 98 computing meeting.
	 Martin wants the first packet - 8000 - reserved.
         Also, right how we are not making any distinction between 
         PbSc and PbGl packets - maybe to be done later */
      dEmcDCMData[i_DCMData].packetID = 8001 + imodule;



      /*  Fill first part */

      dEmcDCMData[i_DCMData].DCM[0] = iflag;
      dEmcDCMData[i_DCMData].DCM[1] = imodule;
      dEmcDCMData[i_DCMData].DCM[2] = ievno;
      dEmcDCMData[i_DCMData].DCM[3] = iclock;
      dEmcDCMData[i_DCMData].DCM[4] = idetid;
      dEmcDCMData[i_DCMData].DCM[5] = itimecell;
      dEmcDCMData[i_DCMData].DCM[6] = iprecell;
      dEmcDCMData[i_DCMData].DCM[7] = ipostcell;
      
      icount = 8;
      
      
      for ( ichan = 0; ichan < 144; ichan++)
	{
	  itime = dEmcFEMData[i].data[ichan * 5] & 0x00000FFF;
	  ihigain = (dEmcFEMData[i].data[ichan * 5 + 1] & 0x00000FFF)
	    - (dEmcFEMData[i].data[ichan * 5 + 3] & 0x00000FFF);
	  ilogain = (dEmcFEMData[i].data[ichan * 5 + 2] & 0x00000FFF)
	    - (dEmcFEMData[i].data[ichan * 5 + 4] & 0x00000FFF);

	  

	  /*	  if( itime > 0 || ihigain > 0 || ilogain > 0) */
	  if( itime != 0 || ihigain != 0 || ilogain != 0)
	    {
	      /*      time    9 in 19-16   N in bits 27-20  */
	      /* itime = itime + 0x00090000 + ichan * 0x000FFFFF; */
	      itime = itime + 0x00090000 + ( ichan << 20 );

	      /* 
		 Decide if low or high gain should be taken, and
		 set corresponding bits

	      */
	      
	      //	      if( ilogain < 2000)  /* Take low gain data */

	      ipost = dEmcFEMData[i].data[ichan * 5 + 2] & 0x00000FFF;


	      //	      if( ilogain < 2000)  /* Take low gain data */

	      if(ipost > i_minvalue)        /* Take low gain data */
		{
		  ipost = dEmcFEMData[i].data[ichan * 5 + 2] & 0x00000FFF;
		  ipre = dEmcFEMData[i].data[ichan * 5 + 4] & 0x00000FFF;
		}
	      else
		{
		  ipost = (dEmcFEMData[i].data[ichan * 5 + 1] & 0x00000FFF)
		    + 0x00008000;
		  ipre = (dEmcFEMData[i].data[ichan * 5 + 3] & 0x00000FFF)
		    + 0x00008000;
		}

	      /*
		Take care of channel number and data type bits
	      */

	      /*      post    12 in 19-16  N in bits 27-20  */
	      ipost = ipost + 0x000C0000 + ( ichan << 20);
	      /*      pre    10 in 19-16  N in bits 27-20  */
	      ipre  = ipre + 0x000A0000 + ( ichan << 20);

	      dEmcDCMData[i_DCMData].DCM[icount] = ipost;
	      dEmcDCMData[i_DCMData].DCM[icount + 1] = ipre;
	      dEmcDCMData[i_DCMData].DCM[icount + 2] = itime;
	      
	      icount = icount + 3;
	      
	    }  /* At least one is non-zero - time, logain, higain */
	  
	  
	}  /* Loop over ichan, 144 possible channels */

      for ( j = 0; j < 8; j++)
	{
	  dEmcDCMData[i_DCMData].DCM[icount + j] = 
	    dEmcFEMData[i].userword[j] & 0x0000FFFF;
	}
      icount = icount + 8;
      dEmcDCMData[i_DCMData].DCM[icount] = iparity;
      dEmcDCMData[i_DCMData].DCM[icount + 1] = itrailer;
      
      i_DCMData = i_DCMData + 1;
      
    }  /* Loop over i, all rows of dEmcFEMData */
  
  dEmcDCMData_h->nok = i_DCMData;
  

  return STAFCV_OK;
}
