/*:>--------------------------------------------------------------------
**: compile with cc
**: FILE:       mEmcDCMToRaw.c.template
**: HISTORY:
**:             00jan93-v000a-hpl- Created by stic Version
**:  Id: idl.y,v 1.3 1998/04/20 19:56:35 leitch Exp  
**:<------------------------------------------------------------------*/
#include "mEmcDCMToRaw.h"
#include "emlLib.h"

#include <stdio.h>

/** This module converts the data in DCM format into a generic raw
    data format that serves as input for the reconstruction.
    Detailed Documentation:
    \URL{http://www.phenix.bnl.gov/WWW/emcal/documentation/offline/doc99}
    @author Gabor David \URL{mailto:david@bnl.gov}
    @version 1.0
*/
long mEmcDCMToRaw_(
  TABLE_HEAD_ST    *dEmcDCMData_h,    DEMCDCMDATA_ST      *dEmcDCMData ,
  TABLE_HEAD_ST    *dEmcRawData_h,    DEMCRAWDATA_ST      *dEmcRawData )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mEmcDCMToRaw_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mEmcDCMToRaw.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:        dEmcDCMData    - PLEASE FILL IN DESCRIPTION HERE
**:       dEmcDCMData_h   - header Structure for dEmcDCMData
**:    INOUT:
**:      OUT:
**:        dEmcRawData    - PLEASE FILL IN DESCRIPTION HERE
**:       dEmcRawData_h   - header Structure for dEmcRawData
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/

  short i,j;
  long l;
  int   i_rawdata;
  unsigned short ievno,imodule,isector,ismoffset,itower,ichan;
  unsigned short iarm;

  static long ichany,ichanz,imody,imodz;
  
  
  int icode,igain,itype,iswkey;
  short /* ismodz,ismody, */ iz,iy;
  
    
  long rawdata[5][4608][4][2];   /* Max value for PbGl, PbSc is 2592 only */
  /* 0: time, 1: high post 2: low post, 3: high pre 4: low pre */


#define r_lowgain_convfac  0.001   
#define r_highgain_convfac  0.008   
#define i_highgain_convfac  8   
#define r_tdc_convfac  0.05
#define i_low_ped 4000
#define i_high_ped 4000
#define i_minvalue 100


  /* -------------  Executable ----------------------------------*/


  if(dEmcDCMData_h->nok <= 0)
    {
      printf("Error in mEmcDCMToRaw: DCM data table empty \n");
      return ( STAFCV_BAD);
    }

  for (l = 0; l < sizeof(rawdata)/sizeof(rawdata[0][0][0][0]); l++)
    {
      *((long *)rawdata + l) = 0;
    }
  i_rawdata = 0;          /* row counter on output */
  ievno = dEmcDCMData[0].DCM[2] & 0x0000FFFF;
  
  for ( i = 0; i < dEmcDCMData_h->nok; i++)
    {
      imodule = dEmcDCMData[i].DCM[1] & 0x0000FFFF;
      /*      isector = (imodule & 0xE000) / 0x1FFF; */
      /* New scheme, Jan. 4, 2000, G. David
      isector = ( (imodule & 0xE000) >> 13);
      imod = imodule & 0x1FFF;
      ismoffset = imod * 144;
      */      
      if(imodule != dEmcDCMData[i].packetID - 8001)
	printf("Error in mEmcDCMToRaw: FEM and packetID mismatch \n");
      if(imodule < 108)
	{
	  isector = imodule / 18;
	  iarm = 0;
	  if(isector > 3)
	    {
	      iarm = 1;
	      isector = isector - 2;
	    }
	  imodule = imodule % 18;
	  /* ismody = imodule / 6; -- flagged by scan-build as dead assignment */
	  /* ismodz = imodule % 6; -- flagged by scan-build as dead assignment */
	}
      else
	{
	  iarm = 1;
	  imodule = imodule - 108;
	  isector = imodule / 32;
	  imodule = imodule % 32;
	  /* ismody = imodule / 8; -- flagged by scan-build as dead assignment */
	  /* ismodz = imodule % 8; -- flagged by scan-build as dead assignment */
	}
      
      ismoffset = imodule * 144;

      /* Now loop over variable length data input */
      for(j = 8; j < 450; j++){

	  icode = (dEmcDCMData[i].DCM[j] & 0x000F0000) >> 16;
	  if (icode != 9 && icode != 10 && icode != 12) break;

	  /* Get channel number within FEE module by masking bits 27-20 */
	  ichan = (dEmcDCMData[i].DCM[j] & 0x0FF00000) >> 20;
	  /* Get tower within sector by adding SM lower left offset */
	  itower = ismoffset + ichan;
	  /* Get low-high gain bit */
	  igain = (dEmcDCMData[i].DCM[j] & 0x0008000) >> 15;

	  switch ( icode + 10 * igain)
	    {
	    case 9:             /* Time */
	      rawdata[0][itower][isector][iarm] = 
		dEmcDCMData[i].DCM[j] & 0x00000FFF;
	      break;
	    case 10:            /* Low gain pre, force high gain pre */
	      rawdata[4][itower][isector][iarm] = 
		dEmcDCMData[i].DCM[j] & 0x00000FFF;
	      rawdata[3][itower][isector][iarm] = i_high_ped;
	      break;
	    case 12:            /* Low gain post */
	      rawdata[2][itower][isector][iarm] = 
		dEmcDCMData[i].DCM[j] & 0x00000FFF;
	      break;
	    case 20:            /* High gain pre, force low gain pre */
	      rawdata[3][itower][isector][iarm] = 
		dEmcDCMData[i].DCM[j] & 0x00000FFF;
	      rawdata[4][itower][isector][iarm] = i_low_ped;
	      break;
	    case 22:            /* High gain post */
	      rawdata[1][itower][isector][iarm] = 
		dEmcDCMData[i].DCM[j] & 0x00000FFF;
	      break;
	    default:
	      printf("Error in mEmcDCMToRaw: unrecognized data \n");
	      break;
	    }
	  
	}  /* icode = 9, 10 or 12, valid, real data  */
      
    }     /* Loop over i, all rows of dEmcDCMData table */

  /* Now write out raw data  */

  /* RawData indexing changed, Jan 4, 2000, G. David */

  for ( isector = 0; isector < 4; isector++)
    {
      for ( iarm = 0; iarm < 2; iarm++)
	{
	  
	  for ( itower = 0; itower < 4608; itower++ )
	    {
	      /* If low or high gain post is nonzero, write new RawData */
	      if ( rawdata[1][itower][isector][iarm] > 0 ||
		   rawdata[2][itower][isector][iarm] > 0 )
		{
		  
		  /* Generate missing low or high */
		  if (rawdata[1][itower][isector][iarm] == 0) /* High gain missing */
		    {
		      rawdata[1][itower][isector][iarm] = 
			rawdata[3][itower][isector][iarm] +
			(rawdata[2][itower][isector][iarm] - 
			 rawdata[4][itower][isector][iarm]) / i_highgain_convfac;
		    }

		    /* Low gain missing */
		  if (rawdata[2][itower][isector][iarm] == 0) 
		    {
		      rawdata[2][itower][isector][iarm] = i_minvalue;
		    }
		  dEmcRawData[i_rawdata].id = i_rawdata + 1;
		  dEmcRawData[i_rawdata].evno = ievno;
		  
		  /* New indexing scheme - replaceable with PbSc/PbGlindexer
		     - relies only on what we call "software key"
		     Jan 4. 2000, G. David */

		  ichan = itower % 144;
		  ismoffset = itower - ichan;
		  imodule = ismoffset / 144;
		  /* Relative indices within SM */
		  ichany = ichan / 12;
		  ichanz = ichan % 12;
		  
		  if(iarm == 0 || isector > 1)
		    {
		      imody = imodule / 6;
		      imodz = imodule % 6;
		      iy = 12 * imody + ichany;
		      iz = 12 * imodz + ichanz;
		      itype = 1;
		    }
		  else		  
		    {
		      imody = imodule / 8;
		      imodz = imodule % 8;
		      iy = 12 * imody + ichany;
		      iz = 12 * imodz + ichanz;
		      itype = 2;
		    }

		  dEmcRawData[i_rawdata].type = itype;
		  
		  iswkey = 100000 * iarm + 10000 * isector + 100 * iy + iz;
		  dEmcRawData[i_rawdata].swkey = iswkey;
		  
		  
		  dEmcRawData[i_rawdata].adclopre = 
		    rawdata[4][itower][isector][iarm];
		  dEmcRawData[i_rawdata].adclopost = 
		    rawdata[2][itower][isector][iarm];
		  dEmcRawData[i_rawdata].adchipre = 
		    rawdata[3][itower][isector][iarm];
		  dEmcRawData[i_rawdata].adchipost = 
		    rawdata[1][itower][isector][iarm];
		  dEmcRawData[i_rawdata].tdc = 
		    rawdata[0][itower][isector][iarm];
		  
		  i_rawdata = i_rawdata + 1;   /* Incerement row counter */
		}  /* endif low/high post > 0 : New row in dEmcRawData */
	      
	    }  /* Loop over itower, all towers */
	}  /* Loop over iarm */
      
    }  /* Loop over isector, all sectors */
  
  dEmcRawData_h->nok = i_rawdata;

  return STAFCV_OK;
}
