/*:>--------------------------------------------------------------------
**: FILE:       mEmcCalibTower.c.template
**: HISTORY:
**:             00jan93-v000a-hpl- Created by stic Version
**:  Id: idl.y,v 1.5 1999/02/02 16:03:58 lajoie Exp  
**:<------------------------------------------------------------------*/

#include "mEmcCalibTower.h"
#include "emlLib.h"
#include <math.h>

/** This module makes calibrated data (GeV, ns) from the raw data.
    In case of simulation this is done by trivial subtraction of
    pedestal and multiplication with a fixed gain.  When analyzing
    real data it should be replaced with the detailed calibration
    and correction routines used in online.
    Detailed Documentation:
    \URL{http://www.phenix.bnl.gov/WWW/emcal/documentation/offline/doc99}
    @author Gabor David \URL{mailto:david@bnl.gov}
    @version 1.0
*/
long type_of_call mEmcCalibTower_(
  TABLE_HEAD_ST    *dEmcRawData_h,    DEMCRAWDATA_ST      *dEmcRawData ,
  TABLE_HEAD_ST   *dEmcGeometry_h,   DEMCGEOMETRY_ST     *dEmcGeometry ,
  TABLE_HEAD_ST      *dEmcEvent_h,      DEMCEVENT_ST        *dEmcEvent ,
  TABLE_HEAD_ST *dEmcCalibTower_h, DEMCCALIBTOWER_ST   *dEmcCalibTower )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mEmcCalibTower_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mEmcCalibTower.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:        dEmcRawData    - PLEASE FILL IN DESCRIPTION HERE
**:       dEmcRawData_h   - header Structure for dEmcRawData
**:    INOUT:
**:       dEmcGeometry    - PLEASE FILL IN DESCRIPTION HERE
**:      dEmcGeometry_h   - header Structure for dEmcGeometry
**:          dEmcEvent    - PLEASE FILL IN DESCRIPTION HERE
**:         dEmcEvent_h   - header Structure for dEmcEvent
**:      OUT:
**:     dEmcCalibTower    - PLEASE FILL IN DESCRIPTION HERE
**:    dEmcCalibTower_h   - header Structure for dEmcCalibTower
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/



    long i,j;
    float e_lo,e_hi,tof;       	/* Energy, low and high gain; TOF */
    float e;
    
    const float mult_lothr = 0.005;
    const float mult_hithr = 0.020;
    float mult_lo,mult_hi;	/* Multiplicity with low and high threshold */
    
    short i1,iz,iy;
    float sectore[8];		/* Energy in each sector */
    float sectoret[8];		/* Energy in each sector */
    float tote,totet;

    static int l_first = 1;
    double d_work,d_work1;
    static float torad = M_PI/180.0;
    

    long i_twrkey,iarm,isec;
    
    const float r_tdc_convfac = 0.05;


    static float emc_geom[8][96][48][8];
    /*-------------------------------------------

      Executable

      -----------------------------------------*/


    if( l_first == 1 )
      {
	for (i = 0;  i < dEmcGeometry_h->nok; i++ )
	  {
	    /* Changed indexing in dEmcGeometry Nov 20, 1998 G. David
	    i1 = dEmcGeometry[i].sector    -       1;
	    iz = dEmcGeometry[i].ind[0]    -       1;
	    iy = dEmcGeometry[i].ind[1]    -       1;
	    */

	    iz = dEmcGeometry[i].ind[0];
	    iy = dEmcGeometry[i].ind[1];
	    if(dEmcGeometry[i].arm == 0)
	      {
		i1 = dEmcGeometry[i].sector;
	      }
	    else
	      {
		i1 = 7 - dEmcGeometry[i].sector;
	      }


	    /* Fix the PISA bug for PbGl sector E0 here
	       plus add a few small corrections */
	    /*  This FIX is taken out, since now PISA seems to be OK
		Aug. 30, 1999 G. David
	    switch(i1)
	      {
	      case 0:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] + 1.3;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] - 1.0;
		break;
	      case 1:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] + 1.0;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] - 0.2;
		break;
	      case 2:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] + 1.3;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] + 1.0;
		break;
	      case 3:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] + 1.0;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] + 1.3;
		break;
	      case 4:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] - 2.0;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] + 1.6;
		break;
	      case 5:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] - 2.0;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] - 1.2;
		break;
	      case 6:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] - 11.4;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] + 0.1;
		break;
	      case 7:               
		dEmcGeometry[i].nomxyz[0] = dEmcGeometry[i].nomxyz[0] - 24.4;
		dEmcGeometry[i].nomxyz[1] = dEmcGeometry[i].nomxyz[1] - 12.8;
		break;
	      }
	    */
	    /*  End of geometry fixes */

	    emc_geom[0][iz][iy][i1] = dEmcGeometry[i].nomxyz[0];
	    emc_geom[1][iz][iy][i1] = dEmcGeometry[i].nomxyz[1];
	    emc_geom[2][iz][iy][i1] = dEmcGeometry[i].nomxyz[2];
	    emc_geom[3][iz][iy][i1] = dEmcGeometry[i].nomtheta;
	    emc_geom[4][iz][iy][i1] = dEmcGeometry[i].nomphi;
	    emc_geom[5][iz][iy][i1] = dEmcGeometry[i].nomdist;
	    emc_geom[6][iz][iy][i1] = dEmcGeometry[i].nomflash;
	    d_work1 = dEmcGeometry[i].nomtheta;
	    d_work1 = torad * d_work1;
	    d_work = sin(d_work1);
	    emc_geom[7][iz][iy][i1] = d_work;
	    
	  }
	l_first = 0;
	dEmcGeometry_h->nok = i;
      }


	
    

/* Sanity check of header for table "dEmcRawData"... */
    if( ( dEmcRawData_h->maxlen <= 0 ))
       {
       return STAFCV_BAD;
    }

/* Clear sector energy array */

    for( i=0; i<8 ; i++)
    {
	    sectore[i] = 0.0;
	    sectoret[i] = 0.0;
    }
    
/* Process event */
    j = 0;
    mult_lo = 0. ;
    mult_hi = 0. ;
    tote = 0.0;
    totet = 0.0;
    
    for( i=0; i < dEmcRawData_h->nok; i++ ){
	    j = j + 1 ; 
	    e_lo =  dEmcRawData[i].adclopost - dEmcRawData[i].adclopre ;
	    e_hi =  dEmcRawData[i].adchipost - dEmcRawData[i].adchipre ;
	    e_lo = e_lo * 0.001 ;
	    e_hi = e_hi * 0.008 ;
	    /* Instead of hardwiring use conv. factor, to be retrieved from DB 
	       tof  = dEmcRawData[i].tdc * 0.05 ;
	    */
	    tof  =  dEmcRawData[i].tdc * r_tdc_convfac;
	    /* Changed to "count down from high pedestal
	       Nov. 30, 1999 G.D. */
	    if(e_lo < 0.0) e_lo = - e_lo;
	    if(e_hi < 0.0) e_hi = - e_hi;
	    
	           /* Max(e_lo,i_hi) is the energy */
	    e = (e_lo > e_hi) ? e_lo : e_hi; 	

	           /* Count hit multiplicity */
	    if (e > mult_lothr) mult_lo = mult_lo + 1.0 ;
	    if (e > mult_hithr) mult_hi = mult_hi + 1.0 ;

	           /* Fill calibrated tower structures */
	    dEmcCalibTower[i].id = j ; 
	    dEmcCalibTower[i].hwkey = dEmcRawData[i].hwkey ;
	    dEmcCalibTower[i].swkey = dEmcRawData[i].swkey ;
	    dEmcCalibTower[i].type = dEmcRawData[i].type ;

	    i_twrkey = dEmcRawData[i].swkey;
	    iarm = i_twrkey / 100000;
	    i_twrkey = i_twrkey - 100000 * iarm;
	    isec = i_twrkey / 10000;
	    i_twrkey = i_twrkey - 10000 * isec;
	    iy = i_twrkey / 100;
	    iz = i_twrkey - 100 * iy;

	    i1 = isec;
	    if(iarm == 1) 
	      {
		i1 = 7 - i1;
	      }
	    
	    dEmcCalibTower[i].arm = iarm ;
	    dEmcCalibTower[i].sector = isec ;
	    dEmcCalibTower[i].ind[0] = iz ;
	    dEmcCalibTower[i].ind[1] = iy ;
	    dEmcCalibTower[i].ecal = e ;
	    /* Suppress non-physical tof */
	    if(tof > 0.0 && tof < 16.0) tof = 0.0;
	    
	    dEmcCalibTower[i].tof = tof ;

	    /*
	    i1 = dEmcRawData[i].sector    -       1;
	    iz = dEmcRawData[i].ind[0]    -       1;
	    iy = dEmcRawData[i].ind[1]    -       1;
	    */

	    totet = totet + emc_geom[7][iz][iy][i1] * e;
	    

/* Increment sector energy array */	    

	    sectore[i1] = sectore[i1] + e ;
	    sectoret[i1] = sectoret[i1] + emc_geom[7][iz][iy][i1] * e ;
	    tote = tote + e;

    }

    dEmcCalibTower_h->nok = j ;

    for( i=0; i<8; i++)
    {
	    dEmcEvent[0].sece[i] = sectore[i] ;
	    dEmcEvent[0].secet[i] = sectoret[i] ;
    }
    dEmcEvent[0].twrmultlo = mult_lo;
    dEmcEvent[0].twrmulthi = mult_hi;
    dEmcEvent[0].tote = tote;
    dEmcEvent[0].totet = totet;


   return STAFCV_OK;
}
