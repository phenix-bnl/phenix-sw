/*:>--------------------------------------------------------------------
**: FILE:       mTofAssocPid.c.template
**: HISTORY:
**:             00jan93-v000a-hpl- Created by stic Version
**:  Id: idl.y,v 1.11 1998/06/23 15:52:43 ward Exp  
**:<------------------------------------------------------------------*/
#include <math.h>
#include "mTofAssocPid.h"

#define NODEBUG_PID

long mTofAssocPid_(
  TABLE_HEAD_ST         *pidpar_h,     DTOFPIDPAR_ST           *pidpar ,
  TABLE_HEAD_ST          *assoc_h,     DTOFASSOCIATE_ST         *assoc ,
  TABLE_HEAD_ST            *pid_h,        DTOFPID_ST              *pid )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mTofAssocPid_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mTofAssocPid.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:             pidpar    - PLEASE FILL IN DESCRIPTION HERE
**:            pidpar_h   - header Structure for pidpar
**:              assoc    - PLEASE FILL IN DESCRIPTION HERE
**:             assoc_h   - header Structure for assoc
**:    INOUT:
**:      OUT:
**:                pid    - PLEASE FILL IN DESCRIPTION HERE
**:               pid_h   - header Structure for pid
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/
/* How to define M2 vs p cut line.

momentum resolution is composed of detector resolution and multiple
scattering components;

 (sigma_p/p)**2 = (c0*p)**2+(c1/beta)**2 (1)
 c0: detector resolution component (fitting parameter)
 c1: detector resolution component (fitting parameter)
 
 Squared mass is decomposed as follows;

 (sigma_m2/m**2)**2 = 4(sigma_p/p)**2+4/gamma**4*(c2/L)**2 (2)

 c2: tof resolution
 L: path length at TOF

 (1) and (2) derive the following equation;

 (sigma_m2/m**2)**2 = 4(c0*p)**2+4(c1/beta)**2+4/gamma**4*(c2/L)**2
 
*/


  long i,ix,ipid;

  
  if (pid_h->maxlen >= assoc_h->nok)
    pid_h->nok = assoc_h->nok;
  else {
    printf("pid_h->maxlen=%ld is too small\n", pid_h->maxlen);
    return STAFCV_BAD;
  }

  for (i=0;i<assoc_h->nok;i++) {
    pid[i].id=i;
    pid[i].id_assoc = assoc[i].id;

    pid[i].id_cgl   = assoc[i].id_cgl;
    pid[i].id_cgt   = assoc[i].id_cgt;
    pid[i].id_tof   = assoc[i].id_tof;

    pid[i].slatid = assoc[i].slatid;
    pid[i].tof = assoc[i].tof;
    pid[i].eloss = assoc[i].eloss;
    for (ix=0;ix<3;ix++) {
      pid[i].xtof[ix] = assoc[i].xtof[ix];
      pid[i].xtrk[ix] = assoc[i].xtrk[ix];
      pid[i].vtrk[ix] = assoc[i].vtrk[ix];
    }
    pid[i].tof_stat = assoc[i].tof_stat;
    pid[i].path = assoc[i].path;
    pid[i].beta = assoc[i].beta;
    pid[i].m2 = assoc[i].m2;

    pid[i].charge = assoc[i].charge;

    for (ix=0;ix<3;ix++) {
      pid[i].pxyz[ix] = assoc[i].pxyz[ix];
      pid[i].dpxyz[ix] = assoc[i].dpxyz[ix];
    }
    pid[i].zvertex  = assoc[i].zvertex;
    pid[i].dzvertex = assoc[i].dzvertex;
    pid[i].phi      = assoc[i].phi;
    pid[i].dphi     = assoc[i].dphi;
    pid[i].theta    = assoc[i].theta;
    pid[i].dtheta   = assoc[i].dtheta;
    pid[i].quality  = assoc[i].quality;

    for (ix=0;ix<3;ix++)
      pid[i].momrec_ndist[ix] = assoc[i].momrec_ndist[ix];


    pid[i].pid_stat = 0;
    pid[i].pid = 0;

    for (ipid=0;ipid<pidpar_h->nok;ipid++) {
      float m2_min,m2_max;
      float sm2;
      float p2 = pid[i].pxyz[0]*pid[i].pxyz[0]
	+pid[i].pxyz[1]*pid[i].pxyz[1]+pid[i].pxyz[2]*pid[i].pxyz[2];
      float c[3];
      float beta = pid[i].beta;
      float gamma = 1./sqrtf(1.-beta*beta);
      float path = pid[i].path;
      float m2_pid = pidpar[ipid].m2mean;

      for (ix=0;ix<3;ix++)
	c[ix] = pidpar[ipid].cm2[ix];

      /*      
      sm2 = 2*pid[i].m2*sqrt(c[0]*c[0]*p2
			     +c[1]*c[1]/(beta*beta)
			     +c[2]*c[2]/(path*path)
			     *gamma*gamma*gamma*gamma*beta*beta);
      */
      
      sm2 = 2 * sqrtf((m2_pid * m2_pid * p2 * c[0]) +
		      (m2_pid * m2_pid * (1 + m2_pid / (p2)) * c[1]) +
		      (p2 * (m2_pid + p2) * c[2]));

      m2_min = pidpar[ipid].m2mean-sm2*pidpar[ipid].factor;
      m2_max = pidpar[ipid].m2mean+sm2*pidpar[ipid].factor;

#ifdef DEBUG_PID
      printf("pid = %d\n", pidpar[ipid].pid);
      printf("pmin = %f, p = %f, pmax %f\n",
	     pidpar[ipid].pmin, sqrtf(p2), pidpar[ipid].pmax);
      printf("m2min = %f, m2 %f, m2max %f\n",
	     pidpar[ipid].m2min, pid[i].m2, pidpar[ipid].m2max);
      printf("m2_min %f, m2 %f, m2_max %f\n",
	     m2_min, pid[i].m2, m2_max);
#endif
      
      if ((m2_min<pid[i].m2) && (pid[i].m2<m2_max) &&
	  (pidpar[ipid].m2min<pid[i].m2) &&
	  (pid[i].m2<pidpar[ipid].m2max) &&
	  (pid[i].charge == pidpar[ipid].charge) &&
	  (pidpar[ipid].pmin<sqrtf(p2)) &&
	  (sqrtf(p2)<pidpar[ipid].pmax)) {
	pid[i].pid = pidpar[ipid].pid;
	pid[i].pid_stat = 1;
      }
    }
  }
   return STAFCV_OK;
}

