/******************************************************************************
 * File:mTofPid.c
 * Author: Hiro Sako, University of Tsukuba
 * Purpose:get final tof by subtracting bbc time-zero and
 *         assicate tof hits to tracks
 * Usage:
 * Date: 07/12/98  H. Sako      First Version
 *       10/14/99  A.Kiyomichi  Delete hb4.h
 *****************************************************************************/

#define NO_TOFPATH_COR
#define NO_DEBUG_CGL
#define NO_DEBUG_TOFPROJ
#define NO_DEBUG_PANEL
#define NO_DEBUG_PAD3PROJ
#define NO_DEBUG_TOFPID

#include <math.h>
#include "gsl/gsl_math.h"

#include "mTofPid.h"


static float Pad3Proj(float Rpad3, 
		     float *xl, float *vl, float *x, float *y);

static float TofProj(DTOFGEOPAR_ST *geopar,
		     DTOFASSOCPAR_ST *assocpar, int panelid,
		     float *xl, float *vl, float *x, float *y);

static short get_panelid(DTOFRECONSTRUCTED_ST *rec);

static int get_pid(TABLE_HEAD_ST         *pidpar_h,
		   DTOFPIDPAR_ST           *pidpar,
		   float p, float beta, float path,
		   short charge, unsigned short *pid_stat);


long mTofPid_(
  TABLE_HEAD_ST         *geopar_h,     DTOFGEOPAR_ST           *geopar ,
  TABLE_HEAD_ST       *assocpar_h,   DTOFASSOCPAR_ST         *assocpar ,
  TABLE_HEAD_ST         *pidpar_h,   DTOFPIDPAR_ST             *pidpar ,
  TABLE_HEAD_ST            *rec_h, DTOFRECONSTRUCTED_ST           *rec ,
  TABLE_HEAD_ST            *bbc_h,        DBBCOUT_ST              *bbc ,
  TABLE_HEAD_ST            *cgl_h,   DCGLPARTICLE_ST              *cgl ,
  TABLE_HEAD_ST            *cgt_h,      DCGLTRACK_ST              *cgt ,
  TABLE_HEAD_ST            *dch_h,     DDCHTRACKS_ST              *dch ,
  TABLE_HEAD_ST            *pc1_h,     DPADCLUSTER_ST             *pc1 ,
  TABLE_HEAD_ST            *pc2_h,     DPADCLUSTER_ST             *pc2 ,
  TABLE_HEAD_ST            *pc3_h,     DPADCLUSTER_ST             *pc3 ,
  TABLE_HEAD_ST            *tec_h,      DTECTRACK_ST              *tec ,
  TABLE_HEAD_ST            *pid_h,        DTOFPID_ST              *pid )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mTofPid_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mTofPid.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:             geopar    - PLEASE FILL IN DESCRIPTION HERE
**:            geopar_h   - header Structure for geopar
**:           assocpar    - PLEASE FILL IN DESCRIPTION HERE
**:          assocpar_h   - header Structure for assocpar
**:                rec    - PLEASE FILL IN DESCRIPTION HERE
**:               rec_h   - header Structure for rec
**:                bbc    - PLEASE FILL IN DESCRIPTION HERE
**:               bbc_h   - header Structure for bbc
**:                cgl    - PLEASE FILL IN DESCRIPTION HERE
**:               cgl_h   - header Structure for cgl
**:                cgt    - PLEASE FILL IN DESCRIPTION HERE
**:               cgt_h   - header Structure for cgt
**:                dch    - PLEASE FILL IN DESCRIPTION HERE
**:               dch_h   - header Structure for dch
**:                tec    - PLEASE FILL IN DESCRIPTION HERE
**:               tec_h   - header Structure for tec
**:    INOUT:
**:      OUT:
**:                pid    - PLEASE FILL IN DESCRIPTION HERE
**:               pid_h   - header Structure for pid
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/

/* How to define M2 vs p cut line.

momentum resolution is composed of detector resolution and multiple
scattering components;

 (sigma_p/p)**2 = (c0*p)**2+(c1/beta)**2 (1)
 c0: detector resolution component (fitting parameter)
 c1: detector resolution component (fitting parameter)
 
 Squared mass is decomposed as follows;

 (sigma_m2/m**2)**2 = 4(sigma_p/p)**2+4/gamma**4*(c2/L)**2 (2)

 c2: tof resolution
 L: path length at TOF

 (1) and (2) derive the following equation;

 (sigma_m2/m**2)**2 = 4(c0*p)**2+4(c1/beta)**2+4/gamma**4*(c2/L)**2
 
*/

    long i,j;
    long panelid;
    long icgt; /* Array index for cgt */
    long idch;
    long itec;
    long itof;
    long ix;
    long ipid = 0;
    float p, p2;
    static long event = 0; /* Event counter to book histgram */

    const float Rpad3 = 500.; /* Flight path to "PAD3" 
				 (R=500cm fixed length)
			      used in mom modules. */
    

    const float clight = 29.9792458; /* cm /ns */


#ifdef DEBUG_CGL
    printf("No. of dCglParticle = %d\n", cgl_h->nok);
#endif


    for (i=0; i<cgl_h->nok; i++){ /* Loop of CglParticle */

      icgt = cgl[i].trackid;

      idch = cgt[icgt].dctracksid;

      itof = cgt[icgt].tofrecid;

      itec = cgt[icgt].tectrackid;


      if (idch>=0) {
	float xl[3],vl[3],y[3],xpad3[3];
	float path_pad3tof;
	float norm_distance;

#ifdef DEBUG_CGL

	printf("CglParticld[%d].id %d\n", i, cgl[i].id);
	printf("CglParticle[%d].trackid %d\n", i, icgt);
	printf("CglTrack[%d].dctracksid %d\n",
	       icgt, cgt[icgt].dctracksid);
	printf("CglTrack[%d].tectrackid %d\n",
	       icgt, cgt[icgt].tectrackid);
	printf("CglParticle[%d].pxyz %f %f %f\n",
	       i, cgl[i].pxyz[0],cgl[i].pxyz[1],cgl[i].pxyz[2]);
	printf("CglParticle[%d].zvertex %f\n",
	       i, cgl[i].zvertex);
	printf("CglParticle[%d].flightdist %f\n",
	       i, cgl[i].flightdist);

	printf("Dch track pos : %f %f %f\n",
	       dch[idch].point[0], dch[idch].point[1], dch[idch].point[2]);

	printf("Dch track vec : %f %f %f\n",
	       dch[idch].direction[0], dch[idch].direction[1],
	       dch[idch].direction[2]);
	printf("bbc t0 [ns]= %f\n", bbc[0].TimeZero);

#endif

	for (ix=0;ix<3;ix++) {
	  xl[ix] = dch[idch].point[ix];
	  vl[ix] = dch[idch].direction[ix];
	}


	/* Track association condition */


	if (itof>=0) {

	  panelid = get_panelid(&rec[itof]);
	  norm_distance = TofProj(geopar, assocpar, panelid,xl,vl,
				  rec[itof].xtof,y);

#ifdef TOFPATH_COR
	  path_pad3tof = Pad3Proj(Rpad3, xl,vl,rec[itof].xtof,
				  xpad3);
#endif

#ifdef DEBUG_TOFPID

	  printf("norm_distance = %f\n", norm_distance);
#ifdef TOFPATH_COR
	  printf("path_pad3tof %f\n", path_pad3tof);
#endif
	  printf("xtof %f %f %f\n", rec[itof].xtof[0],
		 rec[itof].xtof[1], rec[itof].xtof[2]);
	  printf("xpad3 %f %f %f\n", xpad3[0],xpad3[1],xpad3[2]);
#endif

	  pid[ipid].id     = ipid;
	  pid[ipid].id_cgl = i;
	  pid[ipid].id_cgt = icgt;
	  pid[ipid].id_tof = itof;

	  pid[ipid].pid_stat = 1; /* Using dch tracks */


#ifdef DEBUG_TOFPID
	  printf("********** pid data ***********\n");
	  printf("id = %d\n", pid[ipid].id);
	  printf("id_cgl = %d\n", pid[ipid].id_cgl);
	  printf("id_cgt = %d\n", pid[ipid].id_cgt);
	  printf("id_tof = %d\n", pid[ipid].id_tof);
#endif


	  pid[ipid].slatid = rec[itof].slatid;
	  pid[ipid].tof    = rec[itof].tof - bbc[0].TimeZero;
	  pid[ipid].eloss  = rec[itof].eloss;

	  for (ix=0;ix<3;ix++) {
	    pid[ipid].xtof[ix] = rec[itof].xtof[ix];
	    pid[ipid].xtrk[ix] = y[ix];
	    pid[ipid].vtrk[ix] = vl[ix];
	  }
	  
	  pid[ipid].tof_stat = 0;

#ifdef TOFPATH_COR
 	  pid[ipid].path = cgl[i].flightdist + path_pad3tof;
#else
 	  pid[ipid].path = cgl[i].flightdist;
#endif

#ifdef DEBUG_TOFPID
	  printf("cgl Flightdist = %f\n", cgl[i].flightdist);
	  printf("path_pad3tof = %f\n", path_pad3tof);
#endif

	  pid[ipid].beta = pid[ipid].path / (pid[ipid].tof*clight);

	  for (ix=0;ix<3;ix++) {
	    pid[ipid].pxyz[ix]  = cgl[i].pxyz[ix];
	    pid[ipid].dpxyz[ix] = cgl[i].dpxyz[ix];
	  }

	  pid[ipid].charge = cgl[i].charge;

	  p2 = pid[ipid].pxyz[0]*pid[ipid].pxyz[0]
	    +pid[ipid].pxyz[1]*pid[ipid].pxyz[1]
	    +pid[ipid].pxyz[2]*pid[ipid].pxyz[2];

	  if (p2 != 0.)
	    pid[ipid].m2   = p2*(1/(pid[ipid].beta*pid[ipid].beta)-1);
	  else
	    pid[ipid].m2   = -10000;

	  p = sqrtf(p2);
	  pid[ipid].pid = get_pid(pidpar_h, pidpar, p,
				  pid[ipid].beta, pid[ipid].path,
				  pid[ipid].charge, &pid[ipid].pid_stat);

	  pid[ipid].zvertex = cgl[i].zvertex;
	  pid[ipid].dzvertex = cgl[i].dzvertex;
	  pid[ipid].phi = cgl[i].phi;
	  pid[ipid].dphi = cgl[i].dphi;
	  pid[ipid].theta = cgl[i].theta;
	  pid[ipid].dtheta = cgl[i].dtheta;
	  pid[ipid].quality = cgt[icgt].quality;

	  for (ix=0;ix<3;ix++)
	    pid[ipid].momrec_ndist[ix] = cgl[i].momrec_ndist[ix];

	  ipid++;
	  if (pid_h->maxlen < ipid) {
	    printf("pid_h->maxlen %ld, ipid %ld\n",pid_h->maxlen, ipid);
	    pid_h->nok = ipid-1;
	    return STAFCV_BAD;
	  }
	}
      }
    }
    
    pid_h->nok = ipid;
    event++;
    return STAFCV_OK;
}



/* TofProj:
   Project line x = xl+t*vl onto z = r=5063 mm cylinder,
 and get Projection point y, and calculate normalized distance
 from y to Tof hit point x 


 History: Used R=5063 cylinder as an approximation

          09/22/98 H. Sako 
                           Returns normalized distance
        
*/


static float TofProj(DTOFGEOPAR_ST *geopar,
		     DTOFASSOCPAR_ST *assocpar, int panel,
		     float *xl, float *vl, float *x, float *y) {
  const float Rtof = geopar[0].rpos[panel]+geopar[0].rslat; /* [cm] */
  float norm_distance;
  float t;
  float sigmaxy,sigmaz;

  long ix;
  float r,r0,phi,phi0;

  sigmaxy = assocpar[0].sigma_xy;
  sigmaz = assocpar[0].sigma_z;

  /* Method 1 (Exact calculation)

  x-y plane

            |
  phi0=180  |
   -------->|
       r0   |
            |


     Line:   y = xl + t*vl ---- (1)
     Panel:  rcos(phi-phi0)=r0
             y[0] = rcos(phi)
             y[1] = rsin(phi)
              
             rcos(phi)cos(phi0)+rsin(phi)sin(phi0)=r0
             y[0]cos(phi0)+y[1]sin(phi0)=r0 --- (2)

             From (1),(2),
             (xl[0]+t*vl[0])cos(phi0)+(xl[1]+t*vl[1])sin(phi0)=r0
             t = (r0-xl[0]cos(phi0)-xl[1]sin(phi0))
	     /(vl[0]cos(phi0)+vl[1]sin(phi0))             
     */



    r0 = (geopar[0].rpos[panel]+geopar[0].rslat);
    phi0 = geopar[0].phi[panel];

    t = (r0-xl[0]*cosf(phi0/180.*M_PI)-xl[1]*sinf(phi0/180.*M_PI))
      /(vl[0]*cosf(phi0/180.*M_PI)+vl[1]*sinf(phi0/180.*M_PI));

    for (ix=0;ix<3;ix++)
      y[ix] = xl[ix]+t*vl[ix];

    phi = atan2f(y[1],y[0])/M_PI*180.; /* -180 < phi < 180 -> 
				      convert to 0 < phi < 360 */
    if (phi<0) 
      phi += 360.;

#ifdef DEBUG_TOFPROJ
    printf("********* METHOD 1 (EXACT) **********\n");
    printf("panel = %d, phi0 = %f\n", panel, phi0);
    printf("phi, phi0 = %f %f\n", phi, phi0);
#endif
    
    /*    if ((t<0) || fabs(phi-phi0)>22.5/2) {*/
    if (fabs(phi-phi0)>22.5/2) {
      norm_distance = -1.;
    }
    else {
      norm_distance
	= sqrtf(((x[0]-y[0])*(x[0]-y[0])+(x[1]-y[1])*(x[1]-y[1]))
		/(sigmaxy*sigmaxy)
		+(x[2]-y[2])*(x[2]-y[2])/(sigmaz*sigmaz));

    }
    
      

#ifdef DEBUG_TOFPROJ
     printf("\nIn TofProj\n");
     printf("x = %f %f %f\n", x[0],x[1],x[2]);
     printf("xl = %f %f %f\n", xl[0],xl[1],xl[2]);
     printf("vl = %f %f %f\n", vl[0],vl[1],vl[2]);
     printf("y = %f %f %f\n", y[0],y[1],y[2]);
     printf("t = %f\n", t);
     printf("norm_distance = %f\n", norm_distance);
#endif
  
  return norm_distance;
}

static float 
Pad3Proj(float Rpad3, 
	 float *xl, float *vl, float *x, float *y) 
{
  
  float distance;
  float t;
  float phi,phi0, phi1,phi2;


  /* Method 2 (Cylinder Approximation)
     Line:     y = xl + t*vl
     Cylinder: y[0]^2+y[1]^2 = Rtof^2
               (xl[0]+tvl[0])^2+(xl[1]+tvl[1])^2=Rtof^2
	       (vl[0]^2+vl[1]^2)t^2+2(xl[0]*vl[0]+xl[1]*vl[1])t
	       +(xl[0]^2+xl[1]^2)-Rtof^2 = 0

	       A = vl[0]^2+vl[1]^2
	       B = xl[0]vl[0]+xl[1]vl[1]
	       C = xl[0]^2+xl[1]^2-Rtof^2

	       At^2+2Bt+C=0
               A(t+B/A)^2-B^2/A+C=0
                 (t+B/A) = +-sqrt(B^2-AC)/A

	       t = (-B+-sqrt(B^2-AC))/A

      PHENIX coordinate system
        z -> + North, - South
        y -> + upward, - downward
        x -> + West,  - East
       
   */

  float A = vl[0]*vl[0]+vl[1]*vl[1];
  float B = xl[0]*vl[0]+xl[1]*vl[1];
  float C = xl[0]*xl[0]+xl[1]*xl[1]-Rpad3*Rpad3;
  int ix;

  float t1,t2;
  float y1[3],y2[3];

  phi0 = atan2f(x[1],x[0])/M_PI*180.; /* -180 < phi < 180 -> 
				       convert to 0 < phi < 360 */
  if (phi0<0) 
    phi0 += 360.;


  t1 = (-B-sqrtf(B*B-A*C))/A;
  t2 = (-B+sqrtf(B*B-A*C))/A;


  for (ix=0;ix<3;ix++) {
    y1[ix] = xl[ix]+t1*vl[ix];
    y2[ix] = xl[ix]+t2*vl[ix];
  }

  phi1 = atan2f(y1[1],y1[0])/M_PI*180.; /* -180 < phi < 180 -> 
					 convert to 0 < phi < 360 */
  if (phi1<0) 
    phi1 += 360.;

  phi2 = atan2f(y2[1],y2[0])/M_PI*180.; /* -180 < phi < 180 -> 
					 convert to 0 < phi < 360 */
  if (phi2<0) 
    phi2 += 360.;

  /*
  if ((t1<0)&&(t2>=0)) {
    phi = phi2;
    for (ix=0;ix<3;ix++)
      y[ix]=y2[ix];
  }
  else {
  */

  if (fabsf(phi1-phi0)<=fabsf(phi2-phi0)) {
    phi = phi1;
    for (ix=0;ix<3;ix++)
      y[ix] = y1[ix];
  }
  else {
    phi = phi2;
    for (ix=0;ix<3;ix++)
      y[ix] = y2[ix];
  }

  distance = sqrtf((x[0]-y[0])*(x[0]-y[0])+(x[1]-y[1])*(x[1]-y[1])
		   +(x[2]-y[2])*(x[2]-y[2]));


#ifdef DEBUG_PAD3PROJ
  printf("t1 %f, t2 %f\n", t1,t2);
  printf("phi1 %f, phi2 %f, phi0 %f, phi %f\n", phi1,phi2,phi0,phi);
#endif

  return distance;
}


static short 
get_panelid(DTOFRECONSTRUCTED_ST *rec) 
{
  short panelid;

  /* 

Panel name  A B C D F G H I    Sector[1]
panelid     0 1 2 3 4 5 6 7
panel       3 2 1 0 0 1 2 3 
                  E K          Sector[0]
                  8 9

   South side[0]       North side[1]
           
   */

  if (rec->sector == 1) {
    if (rec->side == 0)
      panelid =  -rec->panel + 3;
    else
      panelid = rec->panel + 4;
  } else {
    panelid = rec->side+8;
  }
  
  return panelid;
}

static int get_pid(TABLE_HEAD_ST         *pidpar_h,
		   DTOFPIDPAR_ST           *pidpar,
		   float p, float beta, float path,
		   short charge, unsigned short *pid_stat) {
  int ipidpar;
  int pid = 0;
  int ix;
  
  float m2_min,m2_max;
  float sm2;
  float m2;
  
  m2   = p*p*(1/(beta*beta)-1);
  
  for (ipidpar=0;ipidpar<pidpar_h->nok;ipidpar++) {
    
    float c[3];
    float gamma = 1./sqrtf(1.-beta*beta);
    float m2_pid = pidpar[ipidpar].m2mean;
    
    for (ix=0;ix<3;ix++)
      c[ix] = pidpar[ipidpar].cm2[ix];
    
    /*      sm2 = 2*pid[i].m2*sqrt(c[0]*c[0]*p2
	    +c[1]*c[1]/(beta*beta)
	    +c[2]*c[2]/(path*path)*
	    gamma*gamma*gamma*gamma*beta*beta);
    */
    
    
    sm2 = 2 * sqrtf((m2_pid * m2_pid * p*p * c[0]) +
		    (m2_pid * m2_pid * (1 + m2_pid / (p*p)) * c[1]) +
		    (p*p * (m2_pid + p*p) * c[2]));
    
    
    m2_min = pidpar[ipidpar].m2mean-sm2*pidpar[ipidpar].factor;
    m2_max = pidpar[ipidpar].m2mean+sm2*pidpar[ipidpar].factor;
    
#ifdef DEBUG_PID
    printf("pid = %d\n", pidpar[ipidpar].pid);
    printf("pmin = %f, p = %f, pmax %f\n",
	   pidpar[ipidpar].pmin, sqrtf(p2), pidpar[ipidpar].pmax);
    printf("m2min = %f, m2 %f, m2max %f\n",
	   pidpar[ipidpar].m2min, pid[i].m2, pidpar[ipidpar].m2max);
    printf("m2_min %f, m2 %f, m2_max %f\n",
	   m2_min, pid[i].m2, m2_max);
#endif
    
    if ((m2_min<m2) && (m2<m2_max) &&
	(pidpar[ipidpar].m2min < m2) &&
	(m2 < pidpar[ipidpar].m2max) &&
	(charge == pidpar[ipidpar].charge) &&
	(pidpar[ipidpar].pmin < p) &&
	(p < pidpar[ipidpar].pmax)) {
      pid = pidpar[ipidpar].pid;
      *pid_stat = 1;
    }
  }
  return pid;
}
 
