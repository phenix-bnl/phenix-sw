/******************************************************************************
 * File:mTofRecAssoc.c
 * Author: Hiro Sako, University of Tsukuba
 * Purpose:get final tof by subtracting bbc time-zero and
 *         assicate tof hits to tracks
 * Usage:
 * Date: 07/12/98  H. Sako    First Version
 *****************************************************************************/

#define NO_ASSOC_HIST
#define NO_DEBUG_CGL
#define NO_DEBUG_TOFRECASSOC
#define NO_DEBUG_CLOSEST
#define NO_DEBUG_TOFPROJ
#define NO_DEBUG_PANEL
#define NO_DEBUG_PAD3PROJ
#define NO_DEBUG_TOFASSOC

#include <math.h>
#include "gsl/gsl_math.h"
#include "mTofRecAssoc.h"

static float ClosestApproach(float *xl, float *vl, float *x, float *y);

static float Pad3Proj(float Rpad3, 
		     float *xl, float *vl, float *x, float *y);

static float TofProj(DTOFGEOPAR_ST *geopar,
		     DTOFASSOCPAR_ST *assocpar,
		     int method, int panelid,
		     float *xl, float *vl, float *x, float *y);

static short get_panelid(DTOFRECONSTRUCTED_ST *rec);

long 
mTofRecAssoc_(
  TABLE_HEAD_ST         *geopar_h,     DTOFGEOPAR_ST           *geopar ,
  TABLE_HEAD_ST       *assocpar_h,   DTOFASSOCPAR_ST         *assocpar ,
  TABLE_HEAD_ST            *rec_h, DTOFRECONSTRUCTED_ST              *rec ,
  TABLE_HEAD_ST            *bbc_h,        DBBCOUT_ST              *bbc ,
  TABLE_HEAD_ST            *cgl_h,   DCGLPARTICLE_ST              *cgl ,
  TABLE_HEAD_ST            *cgt_h,      DCGLTRACK_ST              *cgt ,
  TABLE_HEAD_ST            *dch_h,     DDCHTRACKS_ST              *dch ,
  TABLE_HEAD_ST            *pc1_h,     DPADCLUSTER_ST             *pc1 ,
  TABLE_HEAD_ST            *pc2_h,     DPADCLUSTER_ST             *pc2 ,
  TABLE_HEAD_ST            *pc3_h,     DPADCLUSTER_ST             *pc3 ,
  TABLE_HEAD_ST            *tec_h,      DTECTRACK_ST              *tec ,
  TABLE_HEAD_ST            *asc_h,  DTOFASSOCIATE_ST              *asc )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mTofRecAssoc_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mTofRecAssoc.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:             geopar    - PLEASE FILL IN DESCRIPTION HERE
**:            geopar_h   - header Structure for geopar
**:           assocpar    - PLEASE FILL IN DESCRIPTION HERE
**:          assocpar_h   - header Structure for assocpar
**:                rec    - PLEASE FILL IN DESCRIPTION HERE
**:               rec_h   - header Structure for rec
**:                bbc    - PLEASE FILL IN DESCRIPTION HERE
**:               bbc_h   - header Structure for bbc
**:                cgl    - PLEASE FILL IN DESCRIPTION HERE
**:               cgl_h   - header Structure for cgl
**:                cgt    - PLEASE FILL IN DESCRIPTION HERE
**:               cgt_h   - header Structure for cgt
**:                dch    - PLEASE FILL IN DESCRIPTION HERE
**:               dch_h   - header Structure for dch
**:                tec    - PLEASE FILL IN DESCRIPTION HERE
**:               tec_h   - header Structure for tec
**:    INOUT:
**:      OUT:
**:                asc    - PLEASE FILL IN DESCRIPTION HERE
**:               asc_h   - header Structure for asc
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/


    long i,j;
    short panelid;
    short icgt; /* Array index for cgt */
    short idch;
    short itec;
    long ix, i_tof_min;
    long iasc = 0;
    float p2;
    static long event = 0; /* Event counter to book histgram */

    const float Rpad3 = 500.; /* Flight path to "PAD3" 
				 (R=500cm fixed length)
			      used in mom modules. */
    

    const float clight = 29.9792458; /* cm /ns */

#ifdef ASSOC_HIST
    float ntuple[42];
#endif

#ifdef DEBUG_CGL
    printf("No. of dCglParticle = %d\n", cgl_h->nok);
#endif


    for (i=0; i<cgl_h->nok; i++){ /* Loop of CglParticle */
      icgt = cgl[i].trackid;

      if (cgt[icgt].dctracksid >=0)
	idch = dch[cgt[icgt].dctracksid].trackid;
      else
	idch = -1;

      if (cgt[icgt].tectrackid >=0)
	itec = tec[cgt[icgt].tectrackid].id;
      else
	itec = -1;

      if (idch>=0) {
	float xl[3],vl[3],x[3],y[3],ymin[3],xlmin[3],vlmin[3],xpad3[3];
	float path_pad3tof;
	float norm_distance, min_distance;

#ifdef DEBUG_CGL

	printf("CglParticld[%d].id %d\n", i, cgl[i].id);
	printf("CglParticle[%d].trackid %d\n", i, icgt);
	printf("CglTrack[%d].dctracksid %d\n",
	       icgt, cgt[icgt].dctracksid);
	printf("CglTrack[%d].tectrackid %d\n",
	       icgt, cgt[icgt].tectrackid);
	printf("CglParticle[%d].pxyz %f %f %f\n",
	       i, cgl[i].pxyz[0],cgl[i].pxyz[1],cgl[i].pxyz[2]);
	printf("CglParticle[%d].zvertex %f\n",
	       i, cgl[i].zvertex);
	printf("CglParticle[%d].flightdist %f\n",
	       i, cgl[i].flightdist);

	printf("Dch track pos : %f %f %f\n",
	       dch[idch].point[0], dch[idch].point[1], dch[idch].point[2]);

	printf("Dch track vec : %f %f %f\n",
	       dch[idch].direction[0], dch[idch].direction[1],
	       dch[idch].direction[2]);
	printf("bbc t0 [ns]= %f\n", bbc[0].TimeZero);

#endif

	for (ix=0;ix<3;ix++) {
	  xl[ix] = dch[idch].point[ix];
	  vl[ix] = dch[idch].direction[ix];
	}


	min_distance = -1;
	for (ix=0;ix<3;ix++) {
	  ymin[ix] = 0;
	  xlmin[ix] = 0;
	  vlmin[ix] = 0;
	}
	i_tof_min = -1;
	for (j=0; j<rec_h->nok; j++) { /* Loop of dTofRec */
	  

	  for (ix=0;ix<3;ix++)
	    x[ix]  = rec[j].xtof[ix];

	  panelid = get_panelid(&rec[j]);
	  /* Mode : 1=Exact, 2=Cylinder */
	  norm_distance = TofProj(geopar, assocpar, 1, panelid,xl,vl,x,y);
#ifdef DEBUG_PANEL
	  printf("********* rec[%d] ********\n", j);
	  printf("slatid = %d\n", rec[j].slatid);
	  printf("sector = %d\n", rec[j].sector);
	  printf("side = %d\n", rec[j].side);
	  printf("panel = %d\n", rec[j].panel);
	  printf("slat = %d\n", rec[j].slat);
	  printf("panelid = %d\n", panelid);
#endif

	  if (norm_distance > 0.) {
	    if ((min_distance < 0) ||
		((min_distance>=0)&&(norm_distance<min_distance))) {
	      min_distance = norm_distance;
	      i_tof_min = j;
	      for (ix=0;ix<3;ix++) {
		ymin[ix] = y[ix];
		xlmin[ix] = xl[ix];
		vlmin[ix] = vl[ix];
	      }
	    }
	  }
	} /* End loop of dTofRec */

#ifdef DEBUG_TOFASSOC
	printf("min_distance = %f\n", min_distance);
	if (min_distance > 0) {
	  printf("ymin = %f %f %f\n", ymin[0],ymin[1],ymin[2]);
	  printf("vlmin = %f %f %f\n", vlmin[0],vlmin[1],vlmin[2]);
	  printf("xtof = %f %f %f\n",
		 rec[i_tof_min].xtof[0], rec[i_tof_min].xtof[1],
		 rec[i_tof_min].xtof[2]);
	}
#endif

	/* Track association condition */
	if ((min_distance > 0) && (min_distance < assocpar[0].factor)) {

	  path_pad3tof = Pad3Proj(Rpad3, xlmin,vlmin,rec[i_tof_min].xtof,
				xpad3);
#ifdef DEBUG_TOFRECASSOC
	  printf("path_pad3tof %f\n", path_pad3tof);
	  printf("xtof %f %f %f\n", rec[i_tof_min].xtof[0],
		 rec[i_tof_min].xtof[1], rec[i_tof_min].xtof[2]);
	  printf("xpad3 %f %f %f\n", xpad3[0],xpad3[1],xpad3[2]);
#endif

	  asc[iasc].id = iasc;
	  asc[iasc].id_cgl = i;
	  asc[iasc].id_cgt = icgt;
	  asc[iasc].id_dch = idch;
	  asc[iasc].id_tec = itec;
	  asc[iasc].id_tof = i_tof_min;

	  asc[iasc].asc_stat = 1; /* Using dch tracks */


#ifdef DEBUG_TOFRECASSOC
	  printf("********** asc data ***********\n");
	  printf("id = %d\n", asc[iasc].id);
	  printf("id_cgl = %d\n", asc[iasc].id_cgl);
	  printf("id_cgt = %d\n", asc[iasc].id_cgt);
	  printf("id_dch = %d\n", asc[iasc].id_dch);
	  printf("id_tec = %d\n", asc[iasc].id_tec);
	  printf("id_tof = %d\n", asc[iasc].id_tof);
#endif


	  asc[iasc].slatid = rec[i_tof_min].slatid;
	  asc[iasc].tof    = rec[i_tof_min].tof - bbc[0].TimeZero;
	  asc[iasc].eloss  = rec[i_tof_min].eloss;

	  for (ix=0;ix<3;ix++) {
	    asc[iasc].xtof[ix] = rec[i_tof_min].xtof[ix];
	    asc[iasc].xtrk[ix] = ymin[ix];
	    asc[iasc].vtrk[ix] = vlmin[ix];
	  }
	  
	  asc[iasc].tof_stat = 0;

	  asc[iasc].path = cgl[i].flightdist + path_pad3tof;
	  asc[iasc].beta = asc[iasc].path / (asc[iasc].tof*clight);

	  for (ix=0;ix<3;ix++) {
	    asc[iasc].pxyz[ix]  = cgl[i].pxyz[ix];
	    asc[iasc].dpxyz[ix] = cgl[i].dpxyz[ix];
	  }

	  asc[iasc].charge = cgl[i].charge;

	  p2 = asc[iasc].pxyz[0]*asc[iasc].pxyz[0]
	    +asc[iasc].pxyz[1]*asc[iasc].pxyz[1]
	    +asc[iasc].pxyz[2]*asc[iasc].pxyz[2];

	  if (p2 != 0.)
	    asc[iasc].m2   = p2*(1/(asc[iasc].beta*asc[iasc].beta)-1);
	  else
	    asc[iasc].m2   = -10000;

	  asc[iasc].zvertex = cgl[i].zvertex;
	  asc[iasc].dzvertex = cgl[i].dzvertex;
	  asc[iasc].phi = cgl[i].phi;
	  asc[iasc].dphi = cgl[i].dphi;
	  asc[iasc].theta = cgl[i].theta;
	  asc[iasc].dtheta = cgl[i].dtheta;
	  asc[iasc].quality = cgt[icgt].quality;

	  for (ix=0;ix<3;ix++)
	    asc[iasc].momrec_ndist[ix] = cgl[i].momrec_ndist[ix];

#ifdef ASSOC_HIST
	  ntuple[0] = asc[iasc].id;
	  ntuple[1] = asc[iasc].id_cgl;
	  ntuple[2] = asc[iasc].id_cgt;
	  ntuple[3] = asc[iasc].id_dch;
	  ntuple[4] = asc[iasc].id_tec;
	  ntuple[5] = asc[iasc].id_tof;
	  ntuple[6] = asc[iasc].asc_stat;
	  ntuple[7] = asc[iasc].slatid;
	  ntuple[8] = asc[iasc].tof;
	  ntuple[9] = asc[iasc].eloss;
	  for (ix=0;ix<3;ix++)
	    ntuple[10+ix] = asc[iasc].xtof[ix];
	  for (ix=0;ix<3;ix++)
	    ntuple[13+ix] = asc[iasc].xtrk[ix];
	  for (ix=0;ix<3;ix++)
	    ntuple[16+ix] = asc[iasc].vtrk[ix];
	  ntuple[19] = asc[iasc].tof_stat;
	  ntuple[20] = asc[iasc].path;
	  ntuple[21] = asc[iasc].beta;
	  ntuple[22] = asc[iasc].m2;

	  ntuple[23] = asc[iasc].charge;

	  for (ix=0;ix<3;ix++)
	    ntuple[24+ix] = asc[iasc].pxyz[ix];

	  ntuple[27] = sqrtf(asc[iasc].pxyz[0]*asc[iasc].pxyz[0]
			     +asc[iasc].pxyz[1]*asc[iasc].pxyz[1]
			     +asc[iasc].pxyz[2]*asc[iasc].pxyz[2]);

	  for (ix=0;ix<3;ix++)
	    ntuple[28+ix] = asc[iasc].dpxyz[ix];
	  ntuple[31] = asc[iasc].zvertex;
	  ntuple[32] = asc[iasc].dzvertex;
	  ntuple[33] = asc[iasc].phi;
	  ntuple[34] = asc[iasc].dphi;
	  ntuple[35] = asc[iasc].theta;
	  ntuple[36] = asc[iasc].dtheta;
	  ntuple[37] = asc[iasc].quality;
	  for (ix=0;ix<3;ix++)
	    ntuple[38+ix] = asc[iasc].momrec_ndist[ix];
	  ntuple[41] = event;

	  /* delete hb4.h --AK 10/14/99
	  HCDIR("//PHXTOF"," ");
	  HFN(750,ntuple);
	  */
#endif
	  
	  iasc++;
	  if (asc_h->maxlen < iasc) {
	    printf("asc_h->maxlen %ld, iasc %ld\n",asc_h->maxlen, iasc);
	    asc_h->nok = iasc-1;
	    return STAFCV_BAD;
	  }
	}
      }
    }
    
    asc_h->nok = iasc;
    event++;
    return STAFCV_OK;
}


/* Closest approach */
static float ClosestApproach(float *xl, float *vl, float *x, float *y) {
  /* Input :
     xl = 3d position of a line 
     vl = 3d direction vector of a line 
     x  = the point to which the closeset approach is calculated
     Output:
     y  = closest apporach point
     return value = closest approach

     Equations

     y = xl+t*vl (t: parameter)
     (y-x)*vl = 0 

     closest = |y-x|

     vl[i] = (y[i]-xl[i])/t
     y[i] = t*vl[i]+xl[i]
     (y[0]-x[0])vl[0]+(y[1]-x[1])vl[1]+(y[2]-x[1])vl[2]=0
      t*(vl[0]^2+vl[1]^2+vl[2]^2)=x[0]vl[0]+x[1]vl[1]+x[2]vl[2]
                                 -(xl[0]vl[0]+xl[1]vl[1]+xl[2]vl[2])
     */
  int i;

  float closest, t;

  if ((vl[0] != 0) || (vl[1] != 0) || (vl[2] != 0)) {
    t = (x[0]*vl[0]+x[1]*vl[1]+x[2]*vl[2]
	 -(xl[0]*vl[0]+xl[1]*vl[1]+xl[2]*vl[2]))
      /(vl[0]*vl[0]+vl[1]*vl[1]+vl[2]*vl[2]);
    for (i=0;i<3;i++)
      y[i] = t*vl[i]+xl[i];
     closest = sqrtf((y[0]-x[0])*(y[0]-x[0])+(y[1]-x[1])*(y[1]-x[1])
		     +(y[2]-x[2])*(y[2]-x[2]));
#ifdef DEBUG_CLOSEST
     printf("In ClosestApproach \n");
     printf("x = %f %f %f\n", x[0],x[1],x[2]);
     printf("xl = %f %f %f\n", xl[0],xl[1],xl[2]);
     printf("vl = %f %f %f\n", vl[0],vl[1],vl[2]);
     printf("y = %f %f %f\n", y[0],y[1],y[2]);
     printf("t = %f\n", t);
     printf("closest = %f\n", closest);
#endif
     
  }
  else {
    /* vl == 0 */
    return -1;
  }

  
  return closest;
}


/* TofProj:
   Project line x = xl+t*vl onto z = r=5063 mm cylinder,
 and get Projection point y, and calculate normalized distance
 from y to Tof hit point x 


 History: Used R=5063 cylinder as an approximation

          09/22/98 H. Sako 
                           Returns normalized distance
        
*/


static float TofProj(DTOFGEOPAR_ST *geopar,
		     DTOFASSOCPAR_ST *assocpar,
		     int method, int panel,
		     float *xl, float *vl, float *x, float *y) {
  const float Rtof = geopar[0].rpos[panel]+geopar[0].rslat; /* [cm] */
  float norm_distance = -1;
  float t;
  float sigmaxy,sigmaz;

  sigmaxy = assocpar[0].sigma_xy;
  sigmaz = assocpar[0].sigma_z;

  if (method == 1) {
    /* Method 1 (Exact calculation)

  x-y plane

            |
  phi0=180  |
   -------->|
       r0   |
            |


     Line:   y = xl + t*vl ---- (1)
     Panel:  rcos(phi-phi0)=r0
             y[0] = rcos(phi)
             y[1] = rsin(phi)
              
             rcos(phi)cos(phi0)+rsin(phi)sin(phi0)=r0
             y[0]cos(phi0)+y[1]sin(phi0)=r0 --- (2)

             From (1),(2),
             (xl[0]+t*vl[0])cos(phi0)+(xl[1]+t*vl[1])sin(phi0)=r0
             t = (r0-xl[0]cos(phi0)-xl[1]sin(phi0))
	     /(vl[0]cos(phi0)+vl[1]sin(phi0))             
     */

    long ix;
    float r,r0,phi,phi0;


    r0 = (geopar[0].rpos[panel]+geopar[0].rslat);
    phi0 = geopar[0].phi[panel];

    t = (r0-xl[0]*cosf(phi0/180.*M_PI)-xl[1]*sinf(phi0/180.*M_PI))
      /(vl[0]*cosf(phi0/180.*M_PI)+vl[1]*sinf(phi0/180.*M_PI));

    for (ix=0;ix<3;ix++)
      y[ix] = xl[ix]+t*vl[ix];

    phi = atan2f(y[1],y[0])/M_PI*180.; /* -180 < phi < 180 -> 
				      convert to 0 < phi < 360 */
    if (phi<0) 
      phi += 360.;

#ifdef DEBUG_TOFPROJ
    printf("********* METHOD 1 (EXACT) **********\n");
    printf("panel = %d, phi0 = %f\n", panel, phi0);
    printf("phi, phi0 = %f %f\n", phi, phi0);
#endif
    
    if ((t<0) || fabs(phi-phi0)>22.5/2) {
      norm_distance = -1.;
    }
    else {
      norm_distance
	= sqrtf(((x[0]-y[0])*(x[0]-y[0])+(x[1]-y[1])*(x[1]-y[1]))
		/(sigmaxy*sigmaxy)
		+(x[2]-y[2])*(x[2]-y[2])/(sigmaz*sigmaz));

    }
    
      
  }
  else if (method == 2) {

  /* Method 2 (Cylinder Approximation)
     Line:     y = xl + t*vl
     Cylinder: y[0]^2+y[1]^2 = Rtof^2
               (xl[0]+tvl[0])^2+(xl[1]+tvl[1])^2=Rtof^2
	       (vl[0]^2+vl[1]^2)t^2+2(xl[0]*vl[0]+xl[1]*vl[1])t
	       +(xl[0]^2+xl[1]^2)-Rtof^2 = 0

	       A = vl[0]^2+vl[1]^2
	       B = xl[0]vl[0]+xl[1]vl[1]
	       C = xl[0]^2+xl[1]^2-Rtof^2

	       At^2+2Bt+C=0
               A(t+B/A)^2-B^2/A+C=0
                 (t+B/A) = +-sqrt(B^2-AC)/A

	       t = (-B+-sqrt(B^2-AC))/A

      PHENIX coordinate system
        z -> + North, - South
        y -> + upward, - downward
        x -> + West,  - East
       
   */

    float phi0,phi1,phi2,phi;
    float A = vl[0]*vl[0]+vl[1]*vl[1];
    float B = xl[0]*vl[0]+xl[1]*vl[1];
    float C = xl[0]*xl[0]+xl[1]*xl[1]-Rtof*Rtof;
    int ix;
    
    float t1,t2;
    float y1[3],y2[3];
    
#ifdef DEBUG_TOFPROJ
    printf("********* METHOD 2 (CYLINDER) **********\n");
#endif

    phi0 = atan2f(x[1],x[0])/M_PI*180.; /* -180 < phi < 180 -> 
				       convert to 0 < phi < 360 */
    if (phi0<0) 
      phi0 += 360.;
    

    t1 = (-B-sqrtf(B*B-A*C))/A;
    t2 = (-B+sqrtf(B*B-A*C))/A;

    for (ix=0;ix<3;ix++) {
      y1[ix] = xl[ix]+t1*vl[ix];
      y2[ix] = xl[ix]+t2*vl[ix];
    }


    phi1 = atan2f(y1[1],y1[0])/M_PI*180.; /* -180 < phi < 180 -> 
					 convert to 0 < phi < 360 */
    if (phi1<0) 
      phi1 += 360.;
    
    phi2 = atan2f(y2[1],y2[0])/M_PI*180.; /* -180 < phi < 180 -> 
					   convert to 0 < phi < 360 */
    if (phi2<0) 
      phi2 += 360.;
    
    if ((t1<0)&&(t2>=0)) {
      phi = phi2;
      for (ix=0;ix<3;ix++)
	y[ix]=y2[ix];
    }
    else {
      if (fabsf(phi1-phi0)<=fabsf(phi2-phi0)) {
	phi = phi1;
	for (ix=0;ix<3;ix++)
	  y[ix] = y1[ix];
      }
      else {
	phi = phi2;
	for (ix=0;ix<3;ix++)
	  y[ix] = y2[ix];
      }
      
      norm_distance
	= sqrtf(((x[0]-y[0])*(x[0]-y[0])+(x[1]-y[1])*(x[1]-y[1]))
		/(sigmaxy*sigmaxy)
		+(x[2]-y[2])*(x[2]-y[2])/(sigmaz*sigmaz));
    }
  }  

#ifdef DEBUG_TOFPROJ
     printf("\nIn TofProj\n");
     printf("x = %f %f %f\n", x[0],x[1],x[2]);
     printf("xl = %f %f %f\n", xl[0],xl[1],xl[2]);
     printf("vl = %f %f %f\n", vl[0],vl[1],vl[2]);
     printf("y = %f %f %f\n", y[0],y[1],y[2]);
     printf("t = %f\n", t);
     printf("norm_distance = %f\n", norm_distance);
#endif
  
  return norm_distance;
}

static float 
Pad3Proj(float Rpad3, 
	 float *xl, float *vl, float *x, float *y) 
{
  float distance;
  float t;
  float phi,phi0, phi1,phi2;

  /* Method 2 (Cylinder Approximation)
     Line:     y = xl + t*vl
     Cylinder: y[0]^2+y[1]^2 = Rtof^2
               (xl[0]+tvl[0])^2+(xl[1]+tvl[1])^2=Rtof^2
	       (vl[0]^2+vl[1]^2)t^2+2(xl[0]*vl[0]+xl[1]*vl[1])t
	       +(xl[0]^2+xl[1]^2)-Rtof^2 = 0

	       A = vl[0]^2+vl[1]^2
	       B = xl[0]vl[0]+xl[1]vl[1]
	       C = xl[0]^2+xl[1]^2-Rtof^2

	       At^2+2Bt+C=0
               A(t+B/A)^2-B^2/A+C=0
                 (t+B/A) = +-sqrt(B^2-AC)/A

	       t = (-B+-sqrt(B^2-AC))/A

      PHENIX coordinate system
        z -> + North, - South
        y -> + upward, - downward
        x -> + West,  - East
       
   */

  float A = vl[0]*vl[0]+vl[1]*vl[1];
  float B = xl[0]*vl[0]+xl[1]*vl[1];
  float C = xl[0]*xl[0]+xl[1]*xl[1]-Rpad3*Rpad3;
  int ix;

  float t1,t2;
  float y1[3],y2[3];

  phi0 = atan2f(x[1],x[0])/M_PI*180.; /* -180 < phi < 180 -> 
				       convert to 0 < phi < 360 */
  if (phi0<0) 
    phi0 += 360.;


  t1 = (-B-sqrtf(B*B-A*C))/A;
  t2 = (-B+sqrtf(B*B-A*C))/A;


  for (ix=0;ix<3;ix++) {
    y1[ix] = xl[ix]+t1*vl[ix];
    y2[ix] = xl[ix]+t2*vl[ix];
  }

  phi1 = atan2f(y1[1],y1[0])/M_PI*180.; /* -180 < phi < 180 -> 
					 convert to 0 < phi < 360 */
  if (phi1<0) 
    phi1 += 360.;

  phi2 = atan2f(y2[1],y2[0])/M_PI*180.; /* -180 < phi < 180 -> 
					 convert to 0 < phi < 360 */
  if (phi2<0) 
    phi2 += 360.;

  if ((t1<0)&&(t2>=0)) {
    phi = phi2;
    for (ix=0;ix<3;ix++)
      y[ix]=y2[ix];
  }
  else {
    if (fabsf(phi1-phi0)<=fabsf(phi2-phi0)) {
      phi = phi1;
      for (ix=0;ix<3;ix++)
	y[ix] = y1[ix];
    }
    else {
      phi = phi2;
      for (ix=0;ix<3;ix++)
	y[ix] = y2[ix];
    }
  }

  distance = sqrtf((x[0]-y[0])*(x[0]-y[0])+(x[1]-y[1])*(x[1]-y[1])
		   +(x[2]-y[2])*(x[2]-y[2]));


#ifdef DEBUG_PAD3PROJ
  printf("t1 %f, t2 %f\n", t1,t2);
  printf("phi1 %f, phi2 %f, phi0 %f, phi %f\n", phi1,phi2,phi0,phi);
#endif

  return distance;
}

static short 
get_panelid(DTOFRECONSTRUCTED_ST *rec) 
{
  short panelid;

  /* 

Panel name  A B C D F G H I    Sector[1]
panelid     0 1 2 3 4 5 6 7
panel       3 2 1 0 0 1 2 3 
                  E K          Sector[0]
                  8 9

   South side[0]       North side[1]
           
   */

  if (rec->sector == 1) {
    if (rec->side == 0)
      panelid =  -rec->panel + 3;
    else
      panelid = rec->panel + 4;
  } else {
    panelid = rec->side+8;
  }
  
  return panelid;
}
