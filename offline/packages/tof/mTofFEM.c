/*:>--------------------------------------------------------------------
**: File:       mTofFEM.c
**: Author: Hiro Sako, University of Tsukuba
**: Purpose: convert dTofRaw to dTofFEM
**: History:    ?/??/98 H. Sako -- Initial version
**:            10/23/98 H. Sako -- added initialization of dTofFEM_h->nok
**:            10/23/98 H. Sako -- added initialization of
**:                                dTofFEMhitGhit_h->nok
**:            10/23/98 H. Sako   changed exit(1) to return STAFCV_BAD
**:            07/22/99 A. Kiyomichi  fix debug option
**:            05/09/00 A. Kiyomichi  update words 872 -> 1144
**:            06/28/00 A. Kiyomichi  T4 - pedestal
**:<------------------------------------------------------------------*/

#include "tof_FEM.h"
#include "mTofFEM.h"
#include "emlLib.h"
#include <stdio.h>
#include <stdlib.h>

long mTofFEM_(
  TABLE_HEAD_ST        *dTofRaw_h,        DTOFRAW_ST          *dTofRaw ,
  TABLE_HEAD_ST    *dTofGhitRaw_h,    DTOFGHITRAW_ST      *dTofGhitRaw ,
  TABLE_HEAD_ST     *dTofFEMmap_h,     DTOFFEMMAP_ST       *dTofFEMmap ,
  TABLE_HEAD_ST        *dTofFEM_h,        DTOFFEM_ST          *dTofFEM ,
  TABLE_HEAD_ST *dTofFEMhitGhit_h, DTOFFEMHITGHIT_ST   *dTofFEMhitGhit )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mTofFEM_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mTofFEM.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:            dTofRaw    - PLEASE FILL IN DESCRIPTION HERE
**:           dTofRaw_h   - header Structure for dTofRaw
**:        dTofGhitRaw    - PLEASE FILL IN DESCRIPTION HERE
**:       dTofGhitRaw_h   - header Structure for dTofGhitRaw
**:         dTofFEMmap    - PLEASE FILL IN DESCRIPTION HERE
**:        dTofFEMmap_h   - header Structure for dTofFEMmap
**:    INOUT:
**:      OUT:
**:            dTofFEM    - PLEASE FILL IN DESCRIPTION HERE
**:           dTofFEM_h   - header Structure for dTofFEM
**:     dTofFEMhitGhit    - PLEASE FILL IN DESCRIPTION HERE
**:    dTofFEMhitGhit_h   - header Structure for dTofFEMhitGhit
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/

  int iDebug = 0; /* Debug Level 0:no, 1:small 2:full */

  long i,j, ighitraw, ifemhitghit = 0;
  int k;
  short islot;
  short *slatid;
  unsigned short *cell_b, *cell_t, *qvc_b, *qvc_t, *tvc_b, *tvc_t;
  unsigned short *qvc_pre_b, *qvc_pre_t;
  unsigned short qvc_pedestal = 0xfff;  /* simulated QVC pedestal 4095 */
  short *crate, *slot, *ch_b, *ch_t;
  long index, index0;
  /* Index for cell ID */
  long i_cell_clock1, i_cell_clock2, i_cell_clock3, i_cell_clock4; 
  short nFEMdata = 71;  /* 54 -> 71 */
  unsigned short event = 0x123;
  unsigned short link_status = 0x4001;

  slatid    = (short *)malloc(sizeof(short)*dTofRaw_h->nok);
  cell_b    = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  cell_t    = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  qvc_b     = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  qvc_t     = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  qvc_pre_b = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  qvc_pre_t = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  tvc_b     = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  tvc_t     = (unsigned short *)malloc(sizeof(unsigned short)*dTofRaw_h->nok);
  crate     = (short *)malloc(sizeof(short)*dTofRaw_h->nok);
  slot      = (short *)malloc(sizeof(short)*dTofRaw_h->nok);
  ch_b      = (short *)malloc(sizeof(short)*dTofRaw_h->nok);
  ch_t      = (short *)malloc(sizeof(short)*dTofRaw_h->nok);
  

  /* Initialization of nok */

  dTofFEM_h->nok = N_FEM_CRATE; /* No. of crates */

  /* Sanity check of header for table "dTofRaw"... */
  if (( dTofRaw_h->maxlen <= 0 ) ||
     ( dTofRaw_h->nok > dTofRaw_h->maxlen ) ) {
    free(slatid);
    free(cell_b);
    free(cell_t);
    free(qvc_b);
    free(qvc_t);
    free(qvc_pre_b);
    free(qvc_pre_t);
    free(tvc_b);
    free(tvc_t);
    free(crate);
    free(slot);
    free(ch_b);
    free(ch_t);

    return STAFCV_BAD;
  }
  if (( dTofFEM_h->maxlen <= 0 ) ||
     ( dTofFEM_h->nok > dTofFEM_h->maxlen ) ) {
    free(slatid);
    free(cell_b);
    free(cell_t);
    free(qvc_b);
    free(qvc_t);
    free(qvc_pre_b);
    free(qvc_pre_t);
    free(tvc_b);
    free(tvc_t);
    free(crate);
    free(slot);
    free(ch_b);
    free(ch_t);

    return STAFCV_BAD;
  }

  for (j=0; j<dTofFEM_h->nok; j++){ /* Loop of FEM crate */
    short FEM_crate = j;
    
    /* Headers */
    dTofFEM[j].CAV1 = 0xFFFF;

    /* dTofFEM[j].det  = 0x0700; comment out by AK 05-10-00 */
    dTofFEM[j].det  = 0x0007;  /* change Detector ID 0x0700 -> 0x0007 */
    dTofFEM[j].Ecounter = event;
    /* dTofFEM[j].adr  = FEM_crate*0x100; comment out by AK 05-10-00 */
    dTofFEM[j].adr  = FEM_crate + 1; /* change FEM crate address --AK */
    dTofFEM[j].Flag = 0; /* I don't know the UserWord from ArcNet */
    dTofFEM[j].Bcounter = 0; /* I don't know the beam clock counter */
    
    dTofFEM[j].parity = 0;  /* I don't know the parity word */
    dTofFEM[j].CAV2 = 0x0000;
    
    /* Initialize Word */
    for (index=0;index<N_FEM_WORD;index++)
      dTofFEM[j].Word[index] = 0;
    
    /* Loop through FEM and Initialize of FEM data */
    for (islot=0;islot<N_FEM_SLOT;islot++) {
      index0 = islot*nFEMdata;
      
      dTofFEM[j].Word[index0]   = 0x1000+event;   /* Event No. */
      /* module address */
      dTofFEM[j].Word[index0+1] = 0x2000+FEM_crate*0x100+islot*0x10;
      
      dTofFEM[j].Word[index0+2]  = 0x3000+0; /* AMU cell for clock 1 */
      for(k = 0; k < 4; k++){ /* Q1 Initialize */
	dTofFEM[j].Word[index0 + 3 + 4*k + 0]  = 0xCfff;
	dTofFEM[j].Word[index0 + 3 + 4*k + 1]  = 0xDfff;
	dTofFEM[j].Word[index0 + 3 + 4*k + 2]  = 0xEfff;
	dTofFEM[j].Word[index0 + 3 + 4*k + 3]  = 0xFfff;
      }
      dTofFEM[j].Word[index0+19] = 0x3000+0; /* AMU cell for clock 2 */
      for(k = 0; k < 4; k++){ /* Q2 Initialize */
	dTofFEM[j].Word[index0 + 20 + 4*k + 0] = 0xCfff;
	dTofFEM[j].Word[index0 + 20 + 4*k + 1] = 0xDfff;
	dTofFEM[j].Word[index0 + 20 + 4*k + 2] = 0xEfff;
	dTofFEM[j].Word[index0 + 20 + 4*k + 3] = 0xFfff;
      }
      dTofFEM[j].Word[index0+36] = 0x3000+0; /* AMU cell for clock 3 */
      for(k = 0; k < 4; k++){ /* T3 Initialize */
	dTofFEM[j].Word[index0 + 37 + 4*k + 0] = 0x8fff;
	dTofFEM[j].Word[index0 + 37 + 4*k + 1] = 0x9fff;
	dTofFEM[j].Word[index0 + 37 + 4*k + 2] = 0xAfff;
	dTofFEM[j].Word[index0 + 37 + 4*k + 3] = 0xBfff;
      }
      dTofFEM[j].Word[index0+53] = 0x3000+0; /* AMU cell for clock 4 */
      for(k = 0; k < 4; k++){ /* T4 Initialize */
	dTofFEM[j].Word[index0 + 54 + 4*k + 0] = 0x8fff;
	dTofFEM[j].Word[index0 + 54 + 4*k + 1] = 0x9fff;
	dTofFEM[j].Word[index0 + 54 + 4*k + 2] = 0xAfff;
	dTofFEM[j].Word[index0 + 54 + 4*k + 3] = 0xBfff;
      }
      
      dTofFEM[j].Word[index0 + 70] = link_status;
    }
    
    /* Initialize the array size of dTofFEMhitGhit */
    dTofFEMhitGhit_h->nok = dTofGhitRaw_h->nok;

    /* Sanity check of header for table "dTofFEMhitGhit"... */
    if (( dTofFEMhitGhit_h->maxlen <= 0 ) ||
       ( dTofFEMhitGhit_h->nok > dTofFEMhitGhit_h->maxlen )) {
      free(slatid);
      free(cell_b);
      free(cell_t);
      free(qvc_b);
      free(qvc_t);
      free(qvc_pre_b);
      free(qvc_pre_t);
      free(tvc_b);
      free(tvc_t);
      free(crate);
      free(slot);
      free(ch_b);
      free(ch_t);

      return STAFCV_BAD;
    }
    
    for (i=0; i<dTofRaw_h->nok; i++){ /* Loop of raw data */
      slatid[i] = dTofRaw[i].slatid;
      
      crate[i]=dTofFEMmap[slatid[i]].crate;
      
      if (FEM_crate != crate[i]) continue;

#ifdef DEBUG
      printf("dTofRaw[%ld].slatid = %d, FEM_crate %d, crate %d\n", 
	     i, dTofRaw[i].slatid, FEM_crate, crate[i]);
#endif
      
      cell_b[i] = dTofRaw[i].cell[0];
      cell_t[i] = dTofRaw[i].cell[1];

      tvc_b[i]  = dTofRaw[i].tvc[0]; /* T3, T4 */
      tvc_t[i]  = dTofRaw[i].tvc[1];
      qvc_b[i]  = qvc_pedestal - dTofRaw[i].qvc[0]; /* Q2 = Q_ped - Q_post */
      qvc_t[i]  = qvc_pedestal - dTofRaw[i].qvc[1];
      qvc_pre_b[i] = qvc_pedestal;                  /* Q1 = Q_ped - Q_pre */
      qvc_pre_t[i] = qvc_pedestal;
      
      slot[i] =dTofFEMmap[slatid[i]].slot;
      
      ch_b[i] =dTofFEMmap[slatid[i]].ch[0];
      ch_t[i] =dTofFEMmap[slatid[i]].ch[1];
      
      
      /* Fill relation table between
	 FEM data to ghitid (dTofFEMhitGhit) */
      
      for (ighitraw=0;ighitraw<dTofGhitRaw_h->nok; ighitraw++) {
	if (dTofGhitRaw[ighitraw].rawid == i) {
	  dTofFEMhitGhit[ifemhitghit].ghitid = dTofGhitRaw[ighitraw].ghitid;
	  dTofFEMhitGhit[ifemhitghit].slatid = slatid[i];
	  dTofFEMhitGhit[ifemhitghit].crate  = crate[i];
	  dTofFEMhitGhit[ifemhitghit].slot   = slot[i];
	  dTofFEMhitGhit[ifemhitghit].ch[0]  = ch_b[i];
	  dTofFEMhitGhit[ifemhitghit].ch[1]  = ch_t[i];
	  
	  if(iDebug > 2){ /* Debug */
	    printf("slatid (by dTofFEMMap) %d, (by GhitRaw) %d\n",
		   slatid[i], dTofGhitRaw[ighitraw].slatid);
	  }
	  ifemhitghit++;
	}
      }

      /*
      if (ighitraw == dTofGhitRaw_h->nok) {
	printf("No tofghit found with rawid = %d\n",i);
        free(slatid);
        free(cell_b);
        free(cell_t);
        free(qvc_b);
        free(qvc_t);
        free(qvc_pre_b);
        free(qvc_pre_t);
        free(tvc_b);
        free(tvc_t);
        free(crate);
        free(slot);
        free(ch_b);
        free(ch_t);

	return STAFCV_BAD;
      }
      dTofFEMhitGhit[i].ghitid = ighit;
      dTofFEMhitGhit[i].slatid = slatid[i];
      
      dTofFEMhitGhit[i].crate  = crate[i];
      dTofFEMhitGhit[i].slot   = slot[i];
      dTofFEMhitGhit[i].ch[0]  = ch_b[i];
      dTofFEMhitGhit[i].ch[1]  = ch_t[i];
       */
      
      /* End fill dTofFEMhitGhit */

      index0 = slot[i]*nFEMdata; /* nFEMdata = 54 --> 71*/
      /* go to the part of the FEM card */

      i_cell_clock1 = index0+2;
      i_cell_clock2 = index0+19;
      i_cell_clock3 = index0+36;
      i_cell_clock4 = index0+54;

#ifdef DEBUG
      printf("crate: %d, slot: %d\n", crate[i], slot[i]);
      for (k=0; k<=4; k++)
	printf("idata[%ld] = %4d\n", index0+k, dTofFEM[j].Word[index0+k]);
#endif

      /* Bottom channels */
      /* AMU cell */
      dTofFEM[j].Word[i_cell_clock1] += cell_b[i];
      dTofFEM[j].Word[i_cell_clock2] += cell_b[i];
      dTofFEM[j].Word[i_cell_clock3] += cell_b[i];
      dTofFEM[j].Word[i_cell_clock4] += cell_b[i];
      
      /* Q1 QVC-pre */
      index = index0 +  3 + (ch_b[i]%4)*4 + ch_b[i]/4;
      dTofFEM[j].Word[index] = (ch_b[i]/4 + 0xC)*0x1000 + qvc_pre_b[i];

#ifdef DEBUG
      printf("ch_b: %d\n", ch_b[i]);
      printf("[Q1]qvc_pre_b: idata[%ld] = %4d\n",
	     index, dTofFEM[j].Word[index]);
#endif
	
      /* Q2 QVC-post */
      index = index0 + 20 + (ch_b[i]%4)*4 + ch_b[i]/4;
      dTofFEM[j].Word[index] = (ch_b[i]/4 + 0xC)*0x1000 + qvc_b[i];
      
#ifdef DEBUG
      printf("[Q2]qvc_pos_b: idata[%ld] = %4d\n",
	     index, dTofFEM[j].Word[index]);
#endif

      /* T3 TVC  Simulation: T3 == tvc */
      index = index0 + 37 + (ch_b[i]%4)*4 + ch_b[i]/4;
      dTofFEM[j].Word[index] = (ch_b[i]/4 + 0x8)*0x1000 + tvc_b[i];
      
#ifdef DEBUG
      printf("[T3]tvc_b: idata[%ld] = %4d\n",
	     index, dTofFEM[j].Word[index]);
#endif

      /* Top channels */
      /* Q1 QVC-pre */
      index = index0 + 3 + (ch_t[i]%4)*4 + ch_t[i]/4;
      dTofFEM[j].Word[index] = (ch_t[i]/4 + 0xC)*0x1000 + qvc_pre_t[i];

#ifdef DEBUG
      printf("ch_t: %d\n", ch_t[i]);
      printf("[Q1]qvc_pre_t: idata[%ld] = %4d\n",
	     index, dTofFEM[j].Word[index]);
#endif

      /* Q2 QVC-post */
      index = index0 + 20 + (ch_t[i]%4)*4 + ch_t[i]/4;
      dTofFEM[j].Word[index] = (ch_t[i]/4 + 0xC)*0x1000 + qvc_t[i];
      
#ifdef DEBUG
      printf("[Q2]qvc_pos_t: idata[%ld] = %4d\n",
	     index, dTofFEM[j].Word[index]);
#endif
      
      /* T3 TVC  Simulation: T3 == tvc */
      index = index0 + 37 + (ch_t[i]%4)*4 + ch_t[i]/4;
      dTofFEM[j].Word[index] = (ch_t[i]/4 + 0x8)*0x1000 + tvc_t[i];

#ifdef DEBUG
	printf("[T3]tvc_t: idata[%ld] = %4d\n",
	       index, dTofFEM[j].Word[index]);
#endif
    } /* Loop of raw data */

    /* bit 11 is inverted */
    for(k = 0; k<N_FEM_WORD; k++){
      if(dTofFEM[j].Word[k] > 0x8000){
	/* Q1, Q2, T3, T4 - 8###, 9###, a###,,,, f###  */
	dTofFEM[j].Word[k] = dTofFEM[j].Word[k] ^ 0x800;
      }
    }
  } /* j = 0; j < dTofFEM_h->nok; */

  free(slatid);
  free(cell_b);
  free(cell_t);
  free(qvc_b);
  free(qvc_t);
  free(qvc_pre_b);
  free(qvc_pre_t);
  free(tvc_b);
  free(tvc_t);
  free(crate);
  free(slot);
  free(ch_b);
  free(ch_t);

  return STAFCV_OK;
}


/* FEM format (mode 1: Output from the FEM to the DCM)
   Word[1136]: 1136 = 71 * 16 boards

    Data    Bit
   Sequence 15-12   Bits 11-0         Comments
            (hex)
      1     1       Event Number      
      2     2       FEM address       FEM serial number
      3     3       AMU cell address  Bit 0-5 (which AMU cell of 64)
                      Clock 1
      4     C       Channel  0 Q1     Bit 11-0 (data)
      5     D       Channel  4 Q1     Bit 11-0 (data)
      6     E       Channel  8 Q1     Bit 11-0 (data)
      7     F       Channel 12 Q1     Bit 11-0 (data)
      8     C       Channel  1 Q1     Bit 11-0 (data)
      9     D       Channel  5 Q1     Bit 11-0 (data)
     10     E       Channel  9 Q1     Bit 11-0 (data)
     11     F       Channel 13 Q1     Bit 11-0 (data)
     12     C       Channel  2 Q1     Bit 11-0 (data)
     13     D       Channel  6 Q1     Bit 11-0 (data)
     14     E       Channel 10 Q1     Bit 11-0 (data)
     15     F       Channel 14 Q1     Bit 11-0 (data)
     16     C       Channel  3 Q1     Bit 11-0 (data)
     17     D       Channel  7 Q1     Bit 11-0 (data)
     18     E       Channel 11 Q1     Bit 11-0 (data)
     19     F       Channel 15 Q1     Bit 11-0 (data)
     20     2       AMU cell address  Bit 0-5 (which AMU cell of 64)
                      Clock 2
     21     C       Channel  0 Q2     Bit 11-0 (data)
     22     D       Channel  4 Q2     Bit 11-0 (data)
     23     E       Channel  8 Q2     Bit 11-0 (data)
     24     F       Channel 12 Q2     Bit 11-0 (data)
     25     C       Channel  1 Q2     Bit 11-0 (data)
     26     D       Channel  5 Q2     Bit 11-0 (data)
     27     E       Channel  9 Q2     Bit 11-0 (data)
     28     F       Channel 13 Q2     Bit 11-0 (data)
     29     C       Channel  2 Q2     Bit 11-0 (data)
     30     D       Channel  6 Q2     Bit 11-0 (data)
     31     E       Channel 10 Q2     Bit 11-0 (data)
     32     F       Channel 14 Q2     Bit 11-0 (data)
     33     C       Channel  3 Q2     Bit 11-0 (data)
     34     D       Channel  7 Q2     Bit 11-0 (data)
     35     E       Channel 11 Q2     Bit 11-0 (data)
     36     F       Channel 15 Q2     Bit 11-0 (data)
     37     2       AMU cell address  Bit 0-5 (which AMU cell of 64)
                      Clock 3
     38     8       Channel  0 T3     Bit 11-0 (data)
     39     9       Channel  4 T3     Bit 11-0 (data)
     40     A       Channel  8 T3     Bit 11-0 (data)
     41     B       Channel 12 T3     Bit 11-0 (data)
     42     8       Channel  1 T3     Bit 11-0 (data)
     43     9       Channel  5 T3     Bit 11-0 (data)
     44     A       Channel  9 T3     Bit 11-0 (data)
     45     B       Channel 13 T3     Bit 11-0 (data)
     46     8       Channel  2 T3     Bit 11-0 (data)
     47     9       Channel  6 T3     Bit 11-0 (data)
     48     A       Channel 10 T3     Bit 11-0 (data)
     49     B       Channel 14 T3     Bit 11-0 (data)
     50     8       Channel  3 T3     Bit 11-0 (data)
     51     9       Channel  7 T3     Bit 11-0 (data)
     52     A       Channel 11 T3     Bit 11-0 (data)
     53     B       Channel 15 T3     Bit 11-0 (data)
     54     2       AMU cell address  Bit 0-5 (which AMU cell of 64)
                      Clock 4
     55     8       Channel  0 T4     Bit 11-0 (data)
     56     9       Channel  4 T4     Bit 11-0 (data)
     57     A       Channel  8 T4     Bit 11-0 (data)
     58     B       Channel 12 T4     Bit 11-0 (data)
     59     8       Channel  1 T4     Bit 11-0 (data)
     60     9       Channel  5 T4     Bit 11-0 (data)
     61     A       Channel  9 T4     Bit 11-0 (data)
     62     B       Channel 13 T4     Bit 11-0 (data)
     63     8       Channel  2 T4     Bit 11-0 (data)
     64     9       Channel  6 T4     Bit 11-0 (data)
     65     A       Channel 10 T4     Bit 11-0 (data)
     66     B       Channel 14 T4     Bit 11-0 (data)
     67     8       Channel  3 T4     Bit 11-0 (data)
     68     9       Channel  7 T4     Bit 11-0 (data)
     69     A       Channel 11 T4     Bit 11-0 (data)
     70     B       Channel 15 T4     Bit 11-0 (data)
     71     4       FEM LINK status
                                      
*/
