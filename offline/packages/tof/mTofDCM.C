/******************************************************************************
 * File: mTofDCM.c
 * Author: Hiro Sako, University of Tsukuba
 * Purpose:convert dTofFEM to dTofDCM
 * Usage:
 * Date: 07/15/98  H. Sako    First Version
 *       09/29/98  H. Sako    Added checking dTofDCM_h->maxlen
 *                            Changed scheme from 0,1,2 to IDTOF_DCM0,1,2
 *       10/23/98  H. Sako    Added initialization of dTofDCM_h->nok
 *       07/22/99  A. Kiyomichi  Fix Packet ID (7000 to 7001)
 *       05/09/00  A. Kiyomichi  update words 872 -> 1144
 *****************************************************************************/

#include <iostream>
#include "tof_FEM.h"
#include "mTofDCM.h"
#include "emlLib.h"
#include "packetConstants.h"

using namespace std;

long mTofDCM_(
  TABLE_HEAD_ST        *dTofFEM_h,        DTOFFEM_ST          *dTofFEM ,
  TABLE_HEAD_ST     *dTofDCMPar_h,     DTOFDCMPAR_ST       *dTofDCMPar ,
  TABLE_HEAD_ST        *dTofDCM_h,        DTOFDCM_ST          *dTofDCM )
{
/*:>--------------------------------------------------------------------
**: ROUTINE:    mTofDCM_
**: DESCRIPTION: Physics Analysis Module ANSI C template.
**:             This is an ANSI C Physics Analysis Module template
**:             automatically generated by stic from mTofDCM.idl.
**:             Please edit comments and code.
**: AUTHOR:     hpl - H.P. Lovecraft, hplovecraft@cthulhu.void
**: ARGUMENTS:
**:       IN:
**:            dTofFEM    - PLEASE FILL IN DESCRIPTION HERE
**:           dTofFEM_h   - header Structure for dTofFEM
**:         dTofDCMPar    - PLEASE FILL IN DESCRIPTION HERE
**:        dTofDCMPar_h   - header Structure for dTofDCMPar
**:    INOUT:
**:      OUT:
**:            dTofDCM    - PLEASE FILL IN DESCRIPTION HERE
**:           dTofDCM_h   - header Structure for dTofDCM
**: RETURNS:    STAF Condition Value
**:>------------------------------------------------------------------*/

  int iDebug = 0; /* Debug Level 0:no, 1:small 2:full */

  long j;
  //long i,j;
  unsigned int *dcm;
  unsigned short *fem;
  short ifem, ich;
  long idcm;
  const short day = 1; /* Day1 = 1, Day-N = 2 */
  long index;
  short maxFEMdata, nFEMdata = 71;  /* 54 -> 71 */

  /* Initialization */
  if (day == 1) 
    dTofDCM_h->nok = N_FEM_CRATE;
  else
    dTofDCM_h->nok = N_FEM_CRATE*2;
  
  if( ( dTofDCM_h->maxlen <= 0 ) ||
      ( dTofDCM_h->nok > dTofDCM_h->maxlen ) ){
    return STAFCV_BAD;
  }
    
  for (j=0; j<dTofDCM_h->nok; j++) { /* Loop of DCM */
    if(dTofDCMPar[j].scheme == 607){
      /* in pass-though mode (Hit Format 607 = IDTOF_DCM2) */ 
      /*          [define by m.chiu 05-08-00] */
      short jfem; // , fem0, nfem;
      dTofDCM[j].scheme = dTofDCMPar[j].scheme; /* data format scheme */ 
      /* packetID = subsystemID*1000+idcm+1 */
      dTofDCM[j].packetID = 7001+j; 
      
#ifdef DEBUG
      short fem0, nfem;
      nfem = 16;
      fem0 = 0;
      cout<<"DCM scheme = "<<dTofDCM[j].scheme
          <<" packetID = " <<dTofDCM[j].packetID<<endl; 
#endif

      dcm = dTofDCM[j].DCM;
      
      jfem = j;
//    nfem = 16;
//    fem0 = 0;

      fem = dTofFEM[jfem].Word;
      /* Inisialize dcm */
      for (index=0;index<N_DCM_WORD607;index++)
	dcm[index] = 0;

      
      dcm[0] = dTofFEM[jfem].CAV1;             /* 0xffff */
      dcm[1] = 0xf0000+dTofFEM[jfem].det;      /* Detecter ID */
      dcm[2] = 0x60000+dTofFEM[jfem].Ecounter; /* FEM Ecounter?? */
      dcm[3] = 0x60000+dTofFEM[jfem].adr;      /* Module Address (Crate) */
      dcm[4] = 0x60000+dTofFEM[jfem].Flag;     /* Flag word? */
      dcm[5] = 0x60000+dTofFEM[jfem].Bcounter; /* Beam clock */
      
#ifdef DEBUG
      cout<<"Day "<<day<<" condition"<<endl;
      cout<<"jdcm "  << j  <<", jfem "<<jfem
          <<", nfem "<<nfem<<", fem0 "<<fem0<<endl; 
      cout<<"dcm[0] (0xffff) = "      <<dcm[0]<<endl;
      cout<<"dcm[1] (Detector ID) = " <<dcm[1]<<endl;
      cout<<"dcm[2] (Event #) = "     <<dcm[2]<<endl;
      cout<<"dcm[3] (DCM Module #) = "<<dcm[3]<<endl;
      cout<<"dcm[4] (Flag Word?) = "  <<dcm[4]<<endl;
      cout<<"dcm[5] (Beam Clock) = "  <<dcm[5]<<endl;
#endif
      idcm = 6;

      maxFEMdata = nFEMdata*16;
      for(ifem = 0; ifem<maxFEMdata; ifem++){
	/* pass-though mode */
	dcm[idcm] = fem[ifem];
#ifdef DEBUG
	cout<<"dcm["<<idcm<<"] = "<<dcm[idcm]<<endl;
#endif
	idcm++;
      }

      dcm[idcm] = 0x70000 + (0xffff & dTofFEM[j].parity); /* Parity Word */
      idcm++;
      dcm[idcm] = 0x70000 + (0xffff & dTofFEM[j].CAV2);   /* Last Word ??*/
      idcm++;
      dTofDCM[j].nWord = idcm; /* No. of valid words */
#ifdef DEBUG
	cout<<"nWord(valid) = "<<dTofDCM[j].nWord<<endl;
#endif
    } else if(dTofDCMPar[j].scheme == 507) {
      /* in zero-suppression mode (Hit Format 507) */
      dTofDCM[j].scheme = dTofDCMPar[j].scheme; 
      cout<<"### Not yet define ###"<<endl;

    } else {
      /* Hit Format 407 ? = IDTOF_DCM0 */
      short jfem, fem0, nfem;
      /* data format scheme can be different among DCMs?*/
      /* dTofDCM[j].scheme = dTofDCMPar[j].scheme; */
      dTofDCM[j].scheme = 407;

      dTofDCM[j].packetID = 7001+j; /* packet ID = subsystemID*1000+idcm
				       changed in 9/24,
				       according to Peter Steinberg's mail */
      /* packetID = subsystemID*1000+idcm+1 :fix 7000 to 7001 07/21/99 -AK */

#ifdef DEBUG
      cout<<"DCM scheme= " <<dTofDCM[j].scheme
          <<"  packetID = "<<dTofDCM[j].packetID<<endl; 
#endif

      dcm = dTofDCM[j].DCM;

      /* Day 1 -> 1 FEE crate (16 FEMs)/ 1 DCM
	 Day N -> 1/2 FEE crate (8 FEMs)/ 1 DCM */
      
      if (day == 1) {
	jfem = j;
	nfem = 16;
	fem0 = 0;
      }
      else {
	jfem = j/2;
	nfem = 8;
	fem0 = (j%2)*nfem;
      }
      fem = dTofFEM[jfem].Word;
      
      /* Inisialize dcm */
      for (index=0;index<N_DCM_WORD;index++)
	dcm[index] = 0;
      
      dcm[0] = 0xf0000+dTofFEM[jfem].Flag; /* Flag word? */
      dcm[1] = 0x60000+j;               /* DCM Module number: */
      dcm[2] = 0x60000+dTofFEM[jfem].Ecounter; /* event #. should be different from FEM Ecounter?? */
      dcm[3] = 0x60000+dTofFEM[jfem].Bcounter; /* Beam clock */
      dcm[4] = 0x60000+dTofFEM[jfem].det;      /* Detecter ID */
	
#ifdef DEBUG
	cout<<"Day "   <<day <<" condition"<<endl;
	cout<<"jdcm "  << j  <<", jfem "   <<jfem
            <<", nfem "<<nfem<<", fem0 "   <<fem0<<endl; 
	cout<<"dcm[0] (Flag word) = "  <<dcm[0]<<endl;
	cout<<"dcm[1] (DCM module#) = "<<dcm[1]<<endl;
	cout<<"dcm[2] (Event #) = "    <<dcm[2]<<endl;
	cout<<"dcm[3] (Beam Clock) = " <<dcm[3]<<endl;
	cout<<"dcm[4] (Detector ID) = "<<dcm[4]<<endl;
#endif
      idcm = 5;
	
      for (ifem = fem0; ifem<nfem; ifem++) {
	unsigned short index0 = nFEMdata*ifem;
	unsigned short index;

	if(iDebug > 1) cout<<"FEM ID = "<<ifem<<endl; /* Debug */

	dcm[idcm] = 0x60000 + (0xfff & fem[index0]); /* FEM event # */
	if(iDebug > 1) /* Debug */
	  cout<<"dcm["<<idcm  <<"] (FEM event #)= "<<dcm[idcm]<<endl;

	dcm[idcm+1] = 0x60000 + (0xfff & fem[index0+1]); /* FEM address */
	if(iDebug > 1) /* Debug */
	  cout<<"dcm["<<idcm+1<<"] (FEM address)= "<<dcm[idcm+1]<<endl;

	dcm[idcm+2] = 0x60000 + (0x3f & fem[index0+36]); /* AMU time */
	if(iDebug > 1) /* Debug */
	  cout<<"dcm["<<idcm+2<<"] (AMU time)   = "<<dcm[idcm+2]<<endl;

	dcm[idcm+3] = 0x60000 + (0x3f & fem[index0+2]); /* AMU Q-pre */
	if(iDebug > 1) /* Debug */
	  cout<<"dcm["<<idcm+3<<"] (AMU Q-pre)  = "<<dcm[idcm+3]<<endl;

	dcm[idcm+4] = 0x60000 + (0x3f & fem[index0+19]); /* AMU Q-post */
	if(iDebug > 1) /* Debug */
	  cout<<"dcm["<<idcm+4<<"] (AMU Q-post) = "<<dcm[idcm+4]<<endl;

	idcm += 5;
	
	for (ich=0;ich<N_FEM_CH;ich++) {
	  unsigned short tvc, qvc_pre, qvc_pos;
	  /* simulated QVC, TVC pedestal 4095 */
	  unsigned short qvc_pedestal = 0xfff;
	  unsigned short tvc_pedestal = 0xfff;
	  /* Assumption:
	     only if tvc, qvc_pre, qvc_pos are all zero,
	     data is zero suppressed. Thus, always a set
	     of (tvc,qvc_pre,qvc_pos) appears at the same time.
	  */
	  
	  /* Time  -- T3 */
	  index = index0 + 37 + (ich%4)*4+ich/4;
	  tvc     = (0xfff & fem[index]) ^ 0x800; /* bit 11 is inverted */
	  if(tvc == tvc_pedestal) tvc -= tvc_pedestal;

	  /* Q-pre  -- [Q_ped - Q1] */
	  index = index0 +  3 + (ich%4)*4+ich/4;
	  qvc_pre = qvc_pedestal - ((0xfff & fem[index]) ^ 0x800); 

	  
	  /* Q-post  -- [Q_ped - Q2] */
	  index = index0 + 20 + (ich%4)*4+ich/4;
	  qvc_pos = qvc_pedestal - ((0xfff & fem[index]) ^ 0x800);
	  
	  /* Comment: IDTOF_DCM0 is 407 */
	  if ((dTofDCMPar[j].scheme == IDTOF_DCM0) ||
	      (tvc != 0) || (qvc_pre != 0) || (qvc_pos != 0)) {
	    
	    dcm[idcm]   = ich*0x100000 + 0xc0000 + tvc;
	    dcm[idcm+1] = ich*0x100000 + 0xa0000 + qvc_pre;
	    dcm[idcm+2] = ich*0x100000 + 0x90000 + qvc_pos;

	    if(iDebug > 1){
	      cout<<"dcm["<<idcm  <<"] (ch="<<ich<<") (tvc)  = "<<dcm[idcm]  <<endl;
	      cout<<"dcm["<<idcm+1<<"] (ch="<<ich<<") (tvc)  = "<<dcm[idcm+1]<<endl;
	      cout<<"dcm["<<idcm+2<<"] (ch="<<ich<<") (tvc)  = "<<dcm[idcm+2]<<endl;
	    }
	    idcm += 3;
	  }
	} /* End of ich loop */
      } /* End of ifem loop */
      dcm[idcm] = 0x70000 + (0xffff & dTofFEM[j].parity); /* Parity Word */
      idcm++;
      dcm[idcm] = 0x70000 + (0xffff & dTofFEM[j].CAV2);   /* Last Word ??*/
      idcm++;
      dTofDCM[j].nWord = idcm; /* No. of valid words */

#ifdef DEBUG
	cout<<"dTofDCM["<<j<<"].nWord(valid) = "<<dTofDCM[j].nWord<<endl;
#endif
    } /* if(scheme == 607) ... else ... */
  } /* for(j = 0; j < 8; j++) */
  if(iDebug > 0){ /* Debug */
    cout<<" IDTOF_DCM0 = "<<IDTOF_DCM0<<endl;
    cout<<" IDTOF_DCM1 = "<<IDTOF_DCM1<<endl;
    cout<<" IDTOF_DCM2 = "<<IDTOF_DCM2<<endl;
    cout<<" IDTOF_DCM3 = "<<IDTOF_DCM3<<endl;
  }
  return STAFCV_OK;
}
