#include <string> 

#define SVXLAYERNUMBER   4
#define SVXLADDERNUMBER  24   // maximum possible number of ladders in a layer
#define SVXSENSORNUMBER  6    // maximum possible number of sensors in a ladder

TCanvas *canvas;

void SetStyle()
{
  gROOT->SetStyle("Plain");
  gStyle->SetPadGridX(1);
  gStyle->SetPadGridY(1);
  gStyle->SetPadTickX(1);
  gStyle->SetPadTickY(1);
  gStyle->SetLabelSize(0.03,"x");
  gStyle->SetLabelSize(0.03,"y");
}

void Makecanvas(const Char_t *canvasname,UInt_t line)
{
//  Char_t CName[100]; 
//  sprintf(CName,"c%d",canvasnum);
  canvas = new TCanvas(canvasname,canvasname,0,0,1280,800);
  canvas->SetGrid();
  canvas->Divide(line,2);
}

void dispsvxPISAshift()
{
  SetStyle();
  gSystem->Load("libsvx.so");

  svxDetectorGeo *geo = new svxDetectorGeo();
  geo->Read_svxPISApar("svxPISA.par.change");

  UInt_t svxSecNlayers=4;                       ///< Number of layers:
  UInt_t nBarLadder[SVXLADDERNUMBER];         ///< max. number of ladders per layer
  UInt_t nBarSensor[SVXSENSORNUMBER];         ///< max. number of sensors per ladder
  UInt_t barSenType[SVXLAYERNUMBER];                        ///< sensor type
  /// Pointers to barrel sensor objects
  Float_t svx_layer_rpos[SVXLAYERNUMBER+1];
  Float_t svx_layer_zpos[SVXLAYERNUMBER];
  Float_t svx_sensor_xsize[SVXLAYERNUMBER];
  Float_t svx_sensor_ysize[SVXLAYERNUMBER];
  Float_t svx_sensor_zsize[SVXLAYERNUMBER];
  Float_t svx_sensor_snzgap[SVXLAYERNUMBER];

  Float_t scx[4][30][6],scy[4][30][6],scz[4][30][6];
  Float_t six[4][30][6],siy[4][30][6],siz[4][30][6];
 
  // Quantities used in reconstruction from the old dSvxGeom table
  Double_t xOffset[SVXLAYERNUMBER];          // x offset. (was pdxoff)
  Double_t zOffset[SVXLAYERNUMBER];          // z offset. (was pdzoff)
  Double_t gasAtten[SVXLAYERNUMBER];         // gas attenuation factor (was pdgas)
  Double_t anodeSpacing[SVXLAYERNUMBER];     // Anode-to-anode spacing (was aasep)
  Double_t pixelLength[SVXLAYERNUMBER];      // Pixel length (was pxlen)
  Double_t sideWidth[SVXLAYERNUMBER];        // Side pixel width (was wside)
  Double_t centerWidth[SVXLAYERNUMBER];      // Center pixel width (was wcent)
  Double_t pixelSpacing[SVXLAYERNUMBER];     // Pixel space line width (was pxsep)
  Double_t cellSpacing[SVXLAYERNUMBER];      // Cell space line width (was clsep)
  Double_t z0Gap[SVXLAYERNUMBER];            // Gap between z=0 parts along wire (was zgap)
  Short_t  nWiresPerLadd[SVXLAYERNUMBER];    // Number of wires per ladder (was npdwr)
  Short_t  nSvxsAcrossWire[SVXLAYERNUMBER];  // Number of svxs across a wire (was npdx)
  Short_t  nSvxsAlongWire[SVXLAYERNUMBER];   // Number of svxs along a wire (was npdz)
 


  
  // read svxPISA.par.ideal ,this is ideal geometry generated by GEANT
  FILE *svxParPISA = fopen("svxPISA.par.ideal","r");
  if ( !svxParPISA ) {std::cerr << "svxDetectorGeo::Read_svxPISApar(): ERROR reading svxPISA.par.ideal file" << endl; return False;}
  char cdummy[120];

  // Skip SVX cage parameters
  for (UInt_t i = 0; i < 9; ++i ) {
    if ( fgets(cdummy, 120, svxParPISA) != cdummy )      {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
    //cout << cdummy << endl;
  }

  // Read number of barrel layers
  if ( fscanf(svxParPISA,"%u",&svxSecNlayers) != 1 ) {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file 1" << endl;}
  if(svxSecNlayers!=SVXLAYERNUMBER) {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file 2" << endl;}

  // Read radial positions of ladders
  for ( UInt_t i = 0; i < svxSecNlayers+1; ++i ) {
    if ( fscanf(svxParPISA,"%e",&svx_layer_rpos[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read Z positions of the detector center (should always be 0) 
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&svx_layer_zpos[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read number of sensor/ladder
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%u",&nBarSensor[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read sensor width (X)
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&svx_sensor_xsize[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read sensor thickness (Y)
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&svx_sensor_ysize[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read sensor length (Z)
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&svx_sensor_zsize[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read x0add
  Float_t x0add[4];
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&x0add[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read snzgap (gap between sensors in z direction)
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&svx_sensor_snzgap[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read dphi
  Float_t dphi[4];
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&dphi[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read tilt
  Float_t tilt[4];
  for ( UInt_t i = 0; i < svxSecNlayers; ++i ) {
    if ( fscanf(svxParPISA,"%e",&tilt[i]) != 1 )  {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
  }

  // Read number of ladders per layer (both sides)
  for (UInt_t i = 0; i < svxSecNlayers; ++i ) {
    Int_t nsec;
    if ( fscanf(svxParPISA,"%d",&nsec) != 1 )           {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
    Int_t nlad;
    nBarLadder[i] = 0;
    for (UInt_t j = 0; j < nsec; ++j ) {
      if ( fscanf(svxParPISA,"%d",&nlad) != 1 )         {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
      nBarLadder[i] += nlad;
    }
    // Skip sector azimuth position
    for (UInt_t j = 0; j < 2; ++j ) {
      if ( fgets(cdummy, 80, svxParPISA) != cdummy )    {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
    }
  }

//  Skip to barrel translation vectors & rotation matrices
    if ( fgets(cdummy, 80, svxParPISA) != cdummy )      {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}

  for (UInt_t ilr = 0; ilr < svxSecNlayers; ++ilr)  {
   unsigned int itemp;
   Float_t temp;
    for (UInt_t ild = 0; ild < nBarLadder[ilr]; ++ild) {
      for (UInt_t isn=0; isn < nBarSensor[ilr]; ++isn) {

        // in Geant, all counters start from 1, not 0, that's why ilr+1, not ilr
        // svx section is always 0 (barrel)
        if ( fscanf(svxParPISA,"%u",&itemp) != 1 )    {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
        if ( itemp != 0 )                {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
        if ( fscanf(svxParPISA,"%u",&itemp) != 1 )    {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
        if ( itemp != ilr+1 )                         {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
        if ( fscanf(svxParPISA,"%u",&itemp) != 1 )    {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
        if ( itemp != ild+1 )                         {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
        if ( fscanf(svxParPISA,"%u",&itemp) != 1 )    {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
        if ( itemp != isn+1 )                         {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}

        // Read and set translation vector
        for ( UInt_t i = 0; i < 3; ++i ) {
          if ( fscanf(svxParPISA,"%e",&temp) != 1 )   {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
            if(i==0) six[ilr][ild][isn] = temp*10000;
      //   if(i==0)    cout << six[ilr][ild][isn] <<endl;
            if(i==1) siy[ilr][ild][isn] = temp*10000;
            if(i==2) siz[ilr][ild][isn] = temp*10000;
        }
        // Read and set rotation matrix
        for ( UInt_t i = 0; i < 3; ++i ) {
          for ( UInt_t j = 0; j < 3; ++j ) {
            if ( fscanf(svxParPISA,"%e",&temp) != 1 ) {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}
            //to be implemented , if necessary
          }
        }
      } // isn
    } // ild
  } // ilr
  if ( fclose(svxParPISA) == EOF )                    {std::cerr << "svxDetectorGeo: ERROR reading svxPISA.par.ideal file" << endl;}

  
  for (UInt_t ilr =0; ilr<svxSecNlayers; ++ilr)  {
    UInt_t itemp;
    Float_t        temp;
    for (UInt_t ild=0; ild<nBarLadder[ilr]; ++ild) {
      for (UInt_t isn=0; isn<nBarSensor[ilr]; ++isn) {
        SvxSensor *sen = geo->GetSensorPtr(ilr,ild,isn);
        scx[ilr][ild][isn] = (sen->get_transVector(0))*10000.;
        scy[ilr][ild][isn] = (sen->get_transVector(1))*10000.;
        scz[ilr][ild][isn] = (sen->get_transVector(2))*10000.;
      }
    }
  }
 //end of read svxPISA.par
  const UInt_t ncanvas = 4;
  const UInt_t ndisplay[ncanvas]= {5,5,10,10}; //W0,E0,W1-0,W1-1,E1-0,E1-1
  const UInt_t ndata_pixel=4;
  const UInt_t ndata_stripL2=5;
  const UInt_t ndata_stripL3=6;
  Double_t x[ndata_pixel]={1,2,3,4};
  UInt_t ilr,ild,isn; 
  Char_t title[50];
  

  for(UInt_t i=0;i<ncanvas;i++){
    if(i== 0)Makecanvas("B0 WEST",4);
    if(i== 1)Makecanvas("B0 EAST",4);
    if(i== 2)Makecanvas("B1 WEST",5);
    if(i== 3)Makecanvas("B1 EAST",5);
    ilr = (i<2) ?  0:1; 

    for(UInt_t j=0;j<ndisplay[i];j++){
      if(i==0) ild=j;//WEST B0
      if(i==1) ild=j+5;//EAST B0
      if(i==2) ild=j;//WEST B1
      if(i==3) ild=j+10;//EAST B1

      canvas->cd(j+1);
      sprintf(title,"Ladder%d",ild);
      Double_t yx[4] = {scx[ilr][ild][0]-six[ilr][ild][0],scx[ilr][ild][1]-six[ilr][ild][1],scx[ilr][ild][2]-six[ilr][ild][2],scx[ilr][ild][3]-six[ilr][ild][3]};
      Double_t yy[4] = {scy[ilr][ild][0]-siy[ilr][ild][0],scy[ilr][ild][1]-siy[ilr][ild][1],scy[ilr][ild][2]-siy[ilr][ild][2],scy[ilr][ild][3]-siy[ilr][ild][3]};
      Double_t yz[4] = {scz[ilr][ild][0]-siz[ilr][ild][0],scz[ilr][ild][1]-siz[ilr][ild][1],scz[ilr][ild][2]-siz[ilr][ild][2],scz[ilr][ild][3]-siz[ilr][ild][3]};
      grx = new TGraph(ndata_pixel,x,yx);
      grx->SetMarkerStyle(20);
      grx->SetMarkerColor(kGreen);
      grx->SetMarkerSize(1.80);
      grx->SetTitle(title);
      grx->GetXaxis()->SetTitle("Sensor#");
      grx->GetYaxis()->SetTitle("(current geometry - geant geometry) (um)");
      grx->GetYaxis()->SetTitleOffset(1.4);
      grx->GetYaxis()->SetRangeUser(-1000,1000);
      grx->Draw("AP"); 

      gry = new TGraph(ndata_pixel,x,yy);     
      gry->SetMarkerStyle(20);
      gry->SetMarkerColor(kBlue);
      gry->SetMarkerSize(1.80);
      gry->Draw("same P"); 
    
      grz = new TGraph(ndata_pixel,x,yz);     
      grz->SetMarkerStyle(20);
      grz->SetMarkerColor(kCyan);
      grz->SetMarkerSize(1.80);
      grz->Draw("same P");
    }
    if(i <2 ){ 
      canvas->cd(6);
      TLegend *leg = new TLegend(0.01,0.01,0.99,0.99);
      leg->SetFillColor(0);
      leg->SetLineColor(10);
      leg->SetBorderSize(0);
      leg->AddEntry(grx,"analysis(x)-GEANT(x)","p");
      leg->AddEntry(gry,"analysis(y)-GEANT(y)","p");
      leg->AddEntry(grz,"analysis(z)-GEANT(z)","p");
      leg->Draw();
    }

  }

  return;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
